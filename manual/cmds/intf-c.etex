\chapter{Interfacing C with Objective Caml} \label{c:intf-c}
\pdfchapter{Interfacing C with Objective Caml}

This chapter describes how user-defined primitives, written in C, can
be linked with Caml code and called from Caml functions.

\section{Overview and compilation information}

\subsection{Declaring primitives}

User primitives are declared in an implementation file or
"struct"\ldots"end" module expression using the "external" keyword:
\begin{alltt}
        external \var{name} : \var{type} = \var{C-function-name}
\end{alltt}
This defines the value name \var{name} as a function with type
\var{type} that executes by calling the given C function.
For instance, here is how the "input" primitive is declared in the
standard library module "Pervasives":
\begin{verbatim}
        external input : in_channel -> string -> int -> int -> int
                       = "input"
\end{verbatim}
Primitives with several arguments are always curried. The C function
does not necessarily have the same name as the ML function.

External functions thus defined can be specified in interface files or
"sig"\ldots"end" signatures either as regular values
\begin{alltt}
        val \var{name} : \var{type}
\end{alltt}
thus hiding their implementation as a C function, or explicitly as
``manifest'' external functions
\begin{alltt}
        external \var{name} : \var{type} = \var{C-function-name}
\end{alltt}
The latter is slightly more efficient, as it allows clients of the
module to call directly the C function instead of going through the
corresponding Caml function. 

\subsection{Implementing primitives}

User primitives with arity $n \leq 5$ are implemented by C functions
that take $n$ arguments of type "value", and return a result of type
"value". The type "value" is the type of the representations for Caml
values. It encodes objects of several base types (integers,
floating-point numbers, strings, \ldots), as well as Caml data
structures. The type "value" and the associated conversion
functions and macros are described in details below.  For instance,
here is the declaration for the C function implementing the "input"
primitive:
\begin{verbatim}
        value input(value channel, value buffer, value offset, value length)
        {
         ...
        }
\end{verbatim}

When the primitive function is applied in a Caml program, the C
function is called with the values of the expressions to which the
primitive is applied as arguments. The value returned by the function is
passed back to the Caml program as the result of the function
application.

User primitives with arity greater than 5 should be implemented by two
C functions. The first function, to be used in conjunction with the
bytecode compiler "ocamlc", receives two arguments: a pointer to an
array of Caml values (the values for the arguments), and an
integer which is the number of arguments provided. The other function,
to be used in conjunction with the native-code compiler "ocamlopt",
takes its arguments directly. For instance, here are the two C
functions for the 7-argument primitive "Nat.add_nat":
\begin{verbatim}
        value add_nat_native(value nat1, value ofs1, value len1,
                             value nat2, value ofs2, value len2,
                             value carry_in)
        {
          ...
        }
        value add_nat_bytecode(value * argv, int argn)
        {
          return add_nat_native(argv[0], argv[1], argv[2], argv[3],
                                argv[4], argv[5], argv[6]);
        }
\end{verbatim}
The names of the two C functions must be given in the primitive
declaration, as follows:
\begin{alltt}
        external \var{name} : \var{type} =
                 \var{bytecode-C-function-name} \var{native-code-C-function-name}
\end{alltt}
For instance, in the case of "add_nat", the declaration is:
\begin{verbatim}
        external add_nat: nat -> int -> int -> nat -> int -> int -> int -> int
                        = "add_nat_bytecode" "add_nat_native"
\end{verbatim}

Implementing a user primitive is actually two separate tasks: on the
one hand, decoding the arguments to extract C values from the given
Caml values, and encoding the return value as a Caml 
value; on the other hand, actually computing the result from the arguments.
Except for very simple primitives, it is often preferable to have two
distinct C functions to implement these two tasks. The first function
actually implements the primitive, taking native C values as
arguments and returning a native C value. The second function,
often called the ``stub code'', is a simple wrapper around the first
function that converts its arguments from Caml values to C values,
call the first function, and convert the returned C value to Caml
value. For instance, here is the stub code for the "input"
primitive:
\begin{verbatim}
        value input(value channel, value buffer, value offset, value length)
        {
          return Val_long(getblock((struct channel *) channel,
                                   &Byte(buffer, Long_val(offset)),
                                   Long_val(length)));
        }
\end{verbatim}
(Here, "Val_long", "Long_val" and so on are conversion macros for the
type "value", that will be described later.) The hard work is
performed by the function  "getblock", which is declared as:
\begin{verbatim}
        long getblock(struct channel * channel, char * p, long n)
        {
          ...
        }
\end{verbatim}

To write C code that operates on Objective Caml values, the following
include files are provided:
\begin{tableau}{|l|p{12cm}|}{Include file}{Provides}
\entree{"caml/mlvalues.h"}{definition of the "value" type, and conversion macros}
\entree{"caml/alloc.h"}{allocation functions (to create structured Caml
objects)}
\entree{"caml/memory.h"}{miscellaneous memory-related functions (for in-place
modification of structures, etc).}
\entree{"caml/fail.h"}{functions for raising exceptions
(see section~\ref{s:c-exceptions})}
\entree{"caml/callback.h"}{callback from C to Caml (see
section~\ref{s:callback}).}
\end{tableau}
These files reside in the "caml/" subdirectory of the Objective Caml
standard library directory (usually "/usr/local/lib/ocaml").

\subsection{Linking C code with Caml code}

The Objective Caml runtime system comprises three main parts: the bytecode
interpreter, the memory manager, and a set of C functions that
implement the primitive operations. Some bytecode instructions are
provided to call these C functions, designated by their offset in a
table of functions (the table of primitives).

In the default mode, the Caml linker produces bytecode for the
standard runtime system, with a standard set of primitives. References
to primitives that are not in this standard set result in the
``unavailable C primitive'' error.

In the ``custom runtime'' mode, the Caml linker scans the
object files and determines the set of required primitives. Then, it
builds a suitable runtime system, by calling the native code linker with:
\begin{itemize}
\item the table of the required primitives
\item a library that provides the bytecode interpreter, the
memory manager, and the standard primitives
\item libraries and object code files (".o" files) mentioned on the
command line for the Caml linker, that provide implementations
for the user's primitives.
\end{itemize}
This builds a runtime system with the required primitives. The Caml
linker generates bytecode for this custom runtime system. The
bytecode is appended to the end of the custom runtime system, so that
it will be automatically executed when the output file (custom
runtime + bytecode) is launched.

To link in ``custom runtime'' mode, execute the "ocamlc" command with:
\begin{itemize}
\item the "-custom" option
\item the names of the desired Caml object files (".cmo" and ".cma" files) 
\item the names of the C object files and libraries (".o" and ".a"
files) that implement the required primitives. (Under Unix, a library
named "lib"\var{name}".a" residing in one of the standard library
directories can also be specified as "-cclib -l"\var{name}.)
\end{itemize}

If you are using the native-code compiler "ocamlopt", the "-custom"
flag is not needed, as the final linking phase of "ocamlopt" always
builds a standalone executable.  To build a mixed Caml/C executable,
execute the "ocamlopt" command with:
\begin{itemize}
\item the names of the desired Caml native object files (".cmx" and
".cmxa" files) 
\item the names of the C object files and libraries (".o" and ".a"
files) that implement the required primitives.
\end{itemize}

\subsection{Building standalone custom runtime systems}
\label{s:custom-runtime}

It is sometimes inconvenient to build a custom runtime system each
time Caml code is linked with C libraries, like "ocamlc -custom" does.
For one thing, the building of the runtime system is slow on some
systems (that have bad linkers or slow remote file systems); for
another thing, the platform-independence of bytecode files is lost,
forcing to perform one "ocamlc -custom" link per platform of interest.

An alternative to "ocamlc -custom" is to build separately a custom
runtime system integrating the desired C libraries, then generate
``pure'' bytecode executables (not containing their own runtime
system) that can run on this custom runtime.  This is achieved by the
"-make_runtime" and "-use_runtime" flags to "ocamlc".  For example,
to build a custom runtime system integrating the C parts of the
``unix'' and ``threads'' libraries, do:
\begin{verbatim}
        ocamlc -make_runtime -o /home/me/ocamlunixrun unix.cma threads.cma \
                -cclib -lunix -cclib -lthreads
\end{verbatim}
To generate a bytecode executable that runs on this runtime system,
do:
\begin{alltt}
        ocamlc -use_runtime /home/me/ocamlunixrun -o myprog \char92
                unix.cma threads.cma {\it{your .cmo and .cma files}}
\end{alltt}
The bytecode executable "myprog" can then be launched as usual:
"myprog" \var{args} or "/home/me/ocamlunixrun myprog" \var{args}.

Notice that the bytecode libraries "unix.cma" and "threads.cma" must
be given twice: when building the runtime system (so that "ocamlc"
knows which C primitives from "-lunix" and "-lthreads" are required)
and also when building the bytecode executable (so that the bytecode
from "unix.cma" and "threads.cma" is actually linked in).

\section{The "value" type}

All Caml objects are represented by the C type "value",
defined in the include file "caml/mlvalues.h", along with macros to
manipulate values of that type. An object of type "value" is either:
\begin{itemize}
\item an unboxed integer
\item a pointer to a block inside the heap (such as the blocks
allocated through one of the \verb"alloc_*" functions below)
\item a pointer to an object outside the heap (e.g., a pointer to a block
allocated by "malloc", or to a C variable).
\end{itemize}

\subsection{Integer values}

Integer values encode 31-bit signed integers (63-bit on 64-bit
architectures). They are unboxed (unallocated).

\subsection{Blocks}

Blocks in the heap are garbage-collected, and therefore have strict
structure constraints. Each block includes a header containing the
size of the block (in words), and the tag of the block.
The tag governs how the contents of the blocks are structured. A tag
lower than "No_scan_tag" indicates a structured block, containing
well-formed values, which is recursively traversed by the garbage
collector. A tag greater than or equal to "No_scan_tag" indicates a
raw block, whose contents are not scanned by the garbage collector.
For the benefits of ad-hoc polymorphic primitives such as equality and
structured input-output, structured and raw blocks are further
classified according to their tags as follows:
\begin{tableau}{|l|p{10cm}|}{Tag}{Contents of the block}
\entree{0 to $\hbox{"No_scan_tag"}-1$}{A structured block (an array of
Caml objects). Each field is a "value".}
\entree{"Closure_tag"}{A closure representing a functional value. The first
word is a pointer to a piece of bytecode, the remaining words are
"value" containing the environment.}
\entree{"String_tag"}{A character string.}
\entree{"Double_tag"}{A double-precision floating-point number.}
\entree{"Double_array_tag"}{An array or record of double-precision
floating-point numbers.}
\entree{"Abstract_tag"}{A block representing an abstract datatype.}
\entree{"Final_tag"}{A block representing an abstract datatype
              with a ``finalization'' function, to be called when
              the block is deallocated.}
\end{tableau}

\subsection{Pointers outside the heap}

Any word-aligned pointer to an address outside the heap can be safely
cast to and from the type "value". This includes pointers returned by
"malloc", and pointers to C variables (of size at least one word)
obtained with the \verb'&' operator.

\section{Representation of Caml data types}

This section describes how Caml data types are encoded in the
"value" type.

\subsection{Atomic types}

\begin{tableau}{|l|l|}{Caml type}{Encoding}
\entree{"int"}{Unboxed integer values.}
\entree{"char"}{Unboxed integer values (ASCII code).}
\entree{"float"}{Blocks with tag "Double_tag".}
\entree{"string"}{Blocks with tag "String_tag".}
\end{tableau}

\subsection{Tuples and records}

Tuples are represented by pointers to blocks, with tag~0.

Records are also represented by zero-tagged blocks. The ordering of
labels in the record type declaration determines the layout of
the record fields: the value associated to the label
declared first is stored in field~0 of the block, the value associated
to the label declared next goes in field~1, and so on.

As an optimization, records whose fields all have static type "float"
are represented as arrays of floating-point numbers, with tag
"Double_array_tag". (See the section below on arrays.)

\subsection{Arrays}

Arrays of integers and pointers are represented like tuples, 
that is, as pointers to blocks tagged~0.  They are accessed with the
"Field" macro for reading and the "modify" function for writing.

Arrays of floating-point numbers (type "float array")
have a special, unboxed, more efficient representation.
These arrays are represented by pointers to blocks with tag
"Double_array_tag".  They should be accessed with the "Double_field"
and "Store_double_field" macros.

\subsection{Concrete types}

Constructed terms are represented either by unboxed integers (for
constant constructors) or by blocks whose tag encode the constructor
(for non-constant constructors). The constant constructors and the
non-constant constructors for a given concrete type are numbered
separately, starting from 0, in the order in which they appear in the
concrete type declaration. Constant constructors are represented by
unboxed integers equal to the constructor number. Non-constant
constructors declared with a $n$-tuple as argument are represented by
a block of size $n$, tagged with the constructor number; the $n$
fields contain the components of its tuple argument. Other
non-constant constructors are represented by a block of size~1, tagged
with the constructor number; the field~0 contains the value of the
constructor argument. Example:

\begin{tableau}{|l|p{8cm}|}{Constructed term}{Representation}
\entree{"()"}{"Val_int(0)"}
\entree{"false"}{"Val_int(0)"}
\entree{"true"}{"Val_int(1)"}
\entree{"[]"}{"Val_int(0)"}
\entree{"h::t"}{Block with size = 2 and tag = 0; first field
contains "h", second field "t"}
\end{tableau}

As a convenience, "caml/mlvalues.h" defines the macros "Val_unit",
"Val_false" and "Val_true" to refer to "()", "false" and "true".

\subsection{Objects}

Objects are represented as zero-tagged blocks. The first field of the
block refers to the object class and associated method suite, in a
format that cannot easily be exploited from C. The remaining fields of
the object contain the values of the instance variables of the object.
Instance variables are stored in the order in which they appear in the
class definition (taking inherited classes into account).

\section{Operations on values}

\subsection{Kind tests}

\begin{itemize}
\item "Is_long("\var{v}")" is true if value \var{v} is an immediate integer,
false otherwise
\item "Is_block("\var{v}")" is true if value \var{v} is a pointer to a block,
and false if it is an immediate integer.
\end{itemize}

\subsection{Operations on integers}

\begin{itemize}
\item "Val_long("\var{l}")" returns the value encoding the "long int" \var{l}.
\item "Long_val("\var{v}")" returns the "long int" encoded in value \var{v}.
\item "Val_int("\var{i}")" returns the value encoding the "int" \var{i}.
\item "Int_val("\var{v}")" returns the "int" encoded in value \var{v}.
\item "Val_bool("\var{x}")" returns the Caml boolean representing the
truth value of the C integer \var{x}.
\item "Bool_val("\var{v}")" returns 0 if \var{v} is the Caml boolean
"false", 1 if \var{v} is "true".
\item "Val_true", "Val_false" represent to Caml booleans "true" and "false".
\end{itemize}

\subsection{Accessing blocks}

\begin{itemize}
\item "Wosize_val("\var{v}")" returns the size of value \var{v}, in words,
excluding the header.
\item "Tag_val("\var{v}")" returns the tag of value \var{v}.
\item "Field("\var{v}", "\var{n}")" returns the value contained in the
$n\th$ field
of the structured block \var{v}. Fields are numbered from 0 to
$\hbox{"Wosize_val"}(v)-1$.
\item "Code_val("\var{v}")" returns the code part of the closure \var{v}.
\item "string_length("\var{v}")" returns the length (number of characters)
of the string \var{v}.
\item "Byte("\var{v}", "\var{n}")" returns the $n\th$ character of the string
\var{v}, with type "char". Characters are numbered from 0 to
$\hbox{"string_length"}(v)-1$.
\item "Byte_u("\var{v}", "\var{n}")" returns the $n\th$ character of the string
\var{v}, with type "unsigned char". Characters are numbered from 0 to
$\hbox{"string_length"}(v)-1$.
\item "String_val("\var{v}")" returns a pointer to the first byte of the string
\var{v}, with type "char *". This pointer is a valid C string: there is a
null character after the last character in the string. However, Caml
strings can contain embedded null characters, that will confuse
the usual C functions over strings. 
\item "Double_val("\var{v}")" returns the floating-point number contained in
value \var{v}, with type "double".
\item "Double_field("\var{v}", "\var{n}")" returns
the $n\th$ element of the array of floating-point numbers \var{v} (a
block tagged "Double_array_tag").
\item "Store_double_field("\var{v}", "\var{n}",
"\var{d}")" stores the double precision floating-point number \var{d}
in the $n\th$ element of the array of floating-point numbers \var{v}.
\end{itemize}
The expressions "Field("\var{v}", "\var{n}")",
"Byte("\var{v}", "\var{n}")" and
"Byte_u("\var{v}", "\var{n}")"
are valid l-values. Hence, they can be assigned to, resulting in an
in-place modification of value \var{v}.
Assigning directly to "Field("\var{v}", "\var{n}")" must
be done with care to avoid confusing the garbage collector (see
below).

\subsection{Allocating blocks}

From the standpoint of the allocation functions, blocks are divided
according to their size as zero-sized blocks, small blocks (with size
less than or equal to \verb"Max_young_wosize"), and large blocks (with
size greater than \verb"Max_young_wosize"). The constant
\verb"Max_young_wosize" is declared in the include file "mlvalues.h". It
is guaranteed to be at least 64 (words), so that any block with
constant size less than or equal to 64 can be assumed to be small. For
blocks whose size is computed at run-time, the size must be compared
against \verb"Max_young_wosize" to determine the correct allocation procedure.

\begin{itemize}
\item
"Atom("\var{t}")" returns an ``atom'' (zero-sized block) with tag \var{t}.
Zero-sized blocks are preallocated outside of the heap. It is
incorrect to try and allocate a zero-sized block using the functions below.
For instance, "Atom(0)" represents the empty array.
\item
"alloc("\var{n}", "\var{t}")" returns a fresh small block of size
$n \leq \hbox{"Max_young_wosize"}$ words, with tag \var{t}. 
If this block is a structured block (i.e. if $t < \hbox{"No_scan_tag"}$), then 
the fields of the block (initially containing garbage) must be initialized
with legal values (using direct assignment to the fields of the block)
before the next allocation.
\item
"alloc_tuple("\var{n}")" returns a fresh small block of size
$n \leq \hbox{"Max_young_wosize"}$ words, with
tag 0. The fields of this block must be filled with legal values
before the next allocation or modification.
\item
"alloc_shr("\var{n}", "\var{t}")" returns a fresh block of size \var{n}, with tag \var{t}.
The size of the block can be greater than \verb"Max_young_wosize". (It
can also be smaller, but in this case it is more efficient to call
"alloc" instead of "alloc_shr".) 
If this block is a structured block (i.e. if $t < \hbox{"No_scan_tag"}$), then 
the fields of the block (initially containing garbage) must be initialized
with legal values (using the "initialize" function described below)
before the next allocation.
\item
"alloc_string("\var{n}")" returns a string value of length \var{n} characters.
The string initially contains garbage.
\item
"copy_string("\var{s}")" returns a string value containing a copy of
the null-terminated C string \var{s} (a "char *").
\item
"copy_double("\var{d}")" returns a floating-point value initialized
with the "double" \var{d}.
\item
"alloc_array("\var{f}", "\var{a}")" allocates an array of values, calling
function \var{f} over each element of the input array \var{a} to transform it
into a value. The array \var{a} is an array of pointers terminated by the
null pointer. The function \var{f} receives each pointer as argument, and
returns a value. The zero-tagged block returned by
"alloc_array("\var{f}", "\var{a}")" is filled with the values returned by the
successive calls to \var{f}.  (This function must not be used to build
an array of floating-point numbers.)
\item
"copy_string_array("\var{p}")" allocates an array of strings, copied from
the pointer to a string array \var{p} (a \verb"char **").
\end{itemize}

\subsection{Raising exceptions} \label{s:c-exceptions}

Two functions are provided to raise two standard exceptions:
\begin{itemize}
\item "failwith("\var{s}")", where \var{s} is a null-terminated C string (with
type \verb"char *"), raises exception "Failure" with argument \var{s}.
\item "invalid_argument("\var{s}")", where \var{s} is a null-terminated C
string (with type \verb"char *"), raises exception "Invalid_argument"
with argument \var{s}.
\end{itemize}

Raising arbitrary exceptions from C is more delicate: the
exception identifier is dynamically allocated by the Caml program, and
therefore must be communicated to the C function using the
registration facility described below in section~\ref{s:register-exn}.
Once the exception identifier is recovered in C, the following
functions actually raise the exception:
\begin{itemize}
\item "raise_constant("\var{id}")" raises the exception \var{id} with
no argument;
\item "raise_with_arg("\var{id}", "\var{v}")" raises the exception
\var{id} with the Caml value \var{v} as argument;
\item "raise_with_string("\var{id}", "\var{s}")", where \var{s} is a
null-terminated C string, raises the exception \var{id} with a copy of
the C string \var{s} as argument.
\end{itemize}

\section{Living in harmony with the garbage collector}

Unused blocks in the heap are automatically reclaimed by the garbage
collector. This requires some cooperation from C code that
manipulates heap-allocated blocks.

\begin{gcrule} After a structured block (a block with tag less than
"No_scan_tag") is allocated, all fields of this block must be filled
with well-formed values before the next allocation operation. If the
block has been allocated with "alloc" or "alloc_tuple", filling is performed
by direct assignment to the fields of the block:
\begin{alltt}
        Field(\var{v}, \var{n}) = \nth{v}{n};
\end{alltt}
If the block has been allocated with "alloc_shr", filling is performed
through the "initialize" function:
\begin{alltt}
        initialize(&Field(\var{v}, \var{n}), \nth{v}{n});
\end{alltt}
\end{gcrule}

The next allocation can trigger a garbage collection. The garbage
collector assumes that all structured blocks contain well-formed
values. Newly created blocks contain random data, which generally do
not represent well-formed values.

If you really need to allocate before the fields can receive their
final value,  first initialize with a constant value (e.g.
"Val_long(0)"), then allocate, then modify the fields with the correct
value (see rule~4).

\begin{gcrule} Local variables and function parameters containing
values must be registered with the garbage collector (using the
"Begin_roots" and "End_roots" macros), if they are to survive a call
to an allocation function.
\end{gcrule}

Registration is performed with the "Begin_roots" set of macros.
"Begin_roots1("\var{v}")" registers variable \var{v} with the garbage
collector.  Generally, \var{v} will be a local variable or a
parameter of your function.  It must be initialized to a valid value
(e.g. "Val_unit") before the first allocation.  Likewise,
"Begin_roots2", \ldots, "Begin_roots5"
let you register up to 5 variables at the same time.  "Begin_root" is
the same as "Begin_roots1".  "Begin_roots_block("\var{ptr}","\var{size}")"
allows you to register an array of roots.  \var{ptr} is a pointer to
the first element, and \var{size} is the number of elements in the
array.

Once registered, each of your variables (or array element) has the
following properties: if it points to a heap-allocated block, this
block (and its contents) will not be reclaimed; moreover, if this
block is relocated by the garbage collector, the variable is updated
to point to the new location for the block.

Each of the "Begin_roots" macros open a C block that must be closed
with a matching "End_roots" at the same nesting level.  The block must
be exited normally (i.e. not with "return" or "goto").  However, the
roots are automatically un-registered if a Caml exception is raised,
so you can exit the block with "failwith", "invalid_argument", or one
of the "raise" functions.

{\bf Note:} The "Begin_roots" macros use a local variable and a
structure tag named "caml__roots_block".  Do not use this identifier
in your programs.

\begin{gcrule} Global variables containing values must be registered
with the garbage collector using the "register_global_root" function.
\end{gcrule}

Registration of a global variable "v" is achieved by calling
"register_global_root(&v)" just before a valid value is stored in "v"
for the first time. 

A registered global variable "v" can be un-registered by calling
"remove_global_root(&v)".

\begin{gcrule} Direct assignment to a field of a block, as in
\begin{alltt}
        Field(\var{v}, \var{n}) = \var{w};
\end{alltt}
is safe only if \var{v} is a block newly allocated by "alloc" or
"alloc_tuple"; that is, if no allocation took place between the
allocation of \var{v} and the assignment to the field. In all other cases,
never assign directly. If the block has just been allocated by "alloc_shr",
use "initialize" to assign a value to a field for the first time:
\begin{alltt}
        initialize(&Field(\var{v}, \var{n}), \var{w});
\end{alltt}
Otherwise, you are updating a field that previously contained a
well-formed value; then, call the "modify" function:
\begin{alltt}
        modify(&Field(\var{v}, \var{n}), \var{w});
\end{alltt}
\end{gcrule}

To illustrate the rules above, here is a C function that builds and
returns a list containing the two integers given as parameters:
\begin{verbatim}
value alloc_list_int(int i1, int i2)
{
  value result = Val_unit;
  value r = Val_unit;

  Begin_roots2 (r, result);
    r = alloc(2, 0);                        /* Allocate a cons cell */
    Field(r, 0) = Val_int(i2);              /* car = the integer i2 */
    Field(r, 1) = Val_int(0);               /* cdr = the empty list [] */
    result = alloc(2, 0);                   /* Allocate the other cons cell */
    Field(result, 0) = Val_int(i1);         /* car = the integer i1 */
    Field(result, 1) = r;                   /* cdr = the first cons cell */
  End_roots ();
  return result;
}
\end{verbatim}
Here, the registering of "result" is not strictly needed, because no
allocation takes place after it gets its value, but it's easier and
safer to simply register all the local variables that have type "value".

In the example above, the list is built bottom-up. Here is an
alternate way, that proceeds top-down. It is less efficient, but
illustrates the use of "modify".
\begin{verbatim}
value alloc_list_int(int i1, int i2)
{
  value tail;
  value r = Val_unit;

  Begin_root (r);
    r = alloc(2, 0);                        /* Allocate a cons cell */
    Field(r, 0) = Val_int(i1);              /* car = the integer i1 */
    Field(r, 1) = Val_int(0);               /* A dummy value
    tail = alloc(2, 0);                     /* Allocate the other cons cell */
    Field(tail, 0) = Val_int(i2);           /* car = the integer i2 */
    Field(tail, 1) = Val_int(0);            /* cdr = the empty list [] */
    modify(&Field(r, 1), tail);             /* cdr of the result = tail */
  End_roots ();
  return r;
}
\end{verbatim}
It would be incorrect to perform
"Field(r, 1) = tail" directly, because the allocation of "tail"
has taken place since "r" was allocated.  "tail" is not registered as
a root because there is no allocation between the assignment where it
takes its value and the "modify" statement that uses the value.

\section{Callbacks from C to Caml} \label{s:callback}

So far, we have described how to call C functions from Caml. In this
section, we show how C functions can call Caml functions, either as
callbacks (Caml calls C which calls Caml), or because the main program
is written in C.

\subsection{Applying Caml closures from C} \label{s:callbacks}

C functions can apply Caml functional values (closures) to Caml values.
The following functions are provided to perform the applications:
\begin{itemize}
\item "callback("\var{f, a}")" applies the functional value \var{f} to
the value \var{a} and return the value returned by~\var{f}.
\item "callback2("\var{f, a, b}")" applies the functional value \var{f}
(which is assumed to be a curried Caml function with two arguments) to
\var{a} and \var{b}.
\item "callback3("\var{f, a, b, c}")" applies the functional value \var{f}
(a curried Caml function with three arguments) to \var{a}, \var{b} and \var{c}.
\end{itemize}
If the function \var{f} does not return, but raises an exception that
escapes the scope of the application, then this exception is
propagated to the next enclosing Caml code, skipping over the C
code. That is, if a Caml function \var{f} calls a C function \var{g} that
calls back a Caml function \var{h} that raises a stray exception, then the
execution of \var{g} is interrupted and the exception is propagated back
into \var{f}.

\subsection{Registering Caml closures for use in C functions}

The main difficulty with the "callback" functions described above is
obtaining a closure to the Caml function to be called. For this
purpose, Objective Caml provides a simple registration mechanism, by
which Caml code can register Caml functions under some global name,
and then C code can retrieve the corresponding closure by this global
name.

On the Caml side, registration is performed by evaluating
"Callback.register" \var{n} \var{v}. Here, \var{n} is the global name
(an arbitrary string) and \var{v} the Caml value. For instance:
\begin{verbatim}
    let f x = print_string "f is applied to "; print_int n; print_newline()
    let _ = Callback.register "test function" f
\end{verbatim}

On the C side, a pointer to the value registered under name \var{n} is
obtained by calling "caml_named_value("\var{n}")". The returned
pointer must then be dereferenced to recover the actual Caml value.
If no value is registered under the name \var{n}, the null pointer is
returned. For example, here is a C wrapper that calls the Caml function "f"
above:
\begin{verbatim}
    void call_caml_f(int arg)
    {
        callback(*caml_named_value("test function"), Val_int(arg));
    }
\end{verbatim}

The pointer returned by "caml_named_value" is constant and can safely
be cached in a C variable to avoid repeated name lookups. On the other
hand, the value pointed to can change during garbage collection and
must always be recomputed at the point of use. Here is a more
efficient variant of "call_caml_f" above that calls "caml_named_value"
only once:
\begin{verbatim}
    void call_caml_f(int arg)
    {
        static value * closure_f = NULL;
        if (closure_f == NULL) {
            /* First time around, look up by name */
            closure_f = caml_named_value("test function");
        }
        callback(*closure_f, Val_int(arg));
    }
\end{verbatim}

\subsection{Registering Caml exceptions for use in C functions} \label{s:register-exn}

The registration mechanism described above can also be used to
communicate exception identifiers from Caml to C. The Caml code
registers the exception by evaluating
"Callback.register_exception" \var{n} \var{exn}, where \var{n} is an
arbitrary name and \var{exn} is an exception value of the
exception to register. For example:
\begin{verbatim}
    exception Error of string
    let _ = Callback.register_exception "test exception" (Error "any string")
\end{verbatim}
The C code can then recover the exception identifier using
"caml_named_value" and pass it as first argument to the functions
"raise_constant", "raise_with_arg", and "raise_with_string" (described
in section~\ref{s:c-exceptions}) to actually raise the exception. For
example, here is a C function that raises the "Error" exception with
the given argument:
\begin{verbatim}
    void raise_error(char * msg)
    {
        raise_with_string(*caml_named_value("test exception"), msg);
    }
\end{verbatim}

\subsection{Main program in C} \label{s:main-c}

In normal operation, a mixed Caml/C program starts by executing the
Caml initialization code, which then may proceed to call C
functions. We say that the main program is the Caml code. In some
applications, it is desirable that the C code plays the role of the
main program, calling Caml functions when needed. This can be achieved as
follows:
\begin{itemize}
\item The C part of the program must provide a "main" function,
which will override the default "main" function provided by the Caml
runtime system. Execution will start in the user-defined "main" function
just like for a regular C program.

\item At some point, the C code must call "caml_main(argv)" to
initialize the Caml code. The "argv" argument is a C array of strings
(type "char **") which represents the command-line arguments, as
passed as second argument to "main". The Caml array "Sys.argv" will
be initialized from this parameter. For the bytecode compiler,
"argv[0]" and "argv[1]" are also consulted to find the file containing
the bytecode.

\item The call to "caml_main" initializes the Caml runtime system,
loads the bytecode (in the case of the bytecode compiler), and
executes the initialization code of the Caml program. Typically, this
initialization code registers callback functions using "Callback.register".
Once the Caml initialization code is complete, control returns to the
C code that called "caml_main".

\item The C code can then invoke Caml functions using the callback
mechanism (see section~\ref{s:callbacks}).
\end{itemize}

\subsection{Embedding the Caml code in the C code} \label{s:embedded-code}

The bytecode compiler in custom runtime mode ("ocamlc -custom")
normally appends the bytecode to the executable file containing the
custom runtime. This has two consequences. First, the final linking
step must be performed by "ocamlc". Second, the Caml runtime library
must be able to find the name of the executable file from the
command-line arguments. When using "caml_main(argv)" as in
section~\ref{s:main-c}, this means that "argv[0]" or "argv[1]" must
contain the executable file name.

An alternative is to embed the bytecode in the C code. The
"-output-obj" option to "ocamlc" is provided for this purpose.
It causes the "ocamlc" compiler to output a C object file (".o" file)
containing the bytecode for the Caml part of the program, as well as a
"caml_startup" function. The C object file produced by "ocamlc
-output-obj" can then be linked with C code using the standard C
compiler, or stored in a C library.

The "caml_startup" function must be called from the main C program in
order to initialize the Caml runtime and execute the Caml
initialization code. Just like "caml_main", it takes one "argv"
parameter containing the command-line parameters. Unlike "caml_main",
this "argv" parameter is used only to initialize "Sys.argv", but not
for finding the name of the executable file.

The native-code compiler "ocamlopt" also supports the "-output-obj"
option, causing it to output a C object file containing the native
code for all Caml modules on the command-line, as well as the Caml
startup code. Initialization is performed by calling "caml_startup" as
in the case of the bytecode compiler.

\paragraph{Warning:} On some ports, special options are required on the final
linking phase that links together the object file produced by the
"-output-obj" option and the remainder of the program.  Those options
are shows in the configuration file "config/Makefile" generated during
compilation of Objective Caml, as the variables "BYTECCLINKOPTS"
(for object files produced by "ocamlc -output-obj") and
"NATIVECCLINKOPTS" (for object files produced by "ocamlopt
-output-obj").  Currently, the only ports that require special
attention are:
\begin{itemize}
\item Digital Unix on the Alpha: object files produced by "ocamlc
-output-obj" must be linked with the "-taso" option.  This is not
necessary for object files produced by "ocamlopt -output-obj".
\item Windows NT: the object file produced by Objective Caml have been
compiled with the "/MT" flag, and therefore all other object files
linked with it should also be compiled with "/MT".
\end{itemize}

\section{A complete example}

This section outlines how the functions from the Unix "curses" library
can be made available to Objective Caml programs. First of all, here is
the interface "curses.mli" that declares the "curses" primitives and
data types:
\begin{verbatim}
type window                   (* The type "window" remains abstract *)
external initscr: unit -> window = "curses_initscr"
external endwin: unit -> unit = "curses_endwin"
external refresh: unit -> unit = "curses_refresh"
external wrefresh : window -> unit = "curses_wrefresh"
external newwin: int -> int -> int -> int -> window = "curses_newwin"
external mvwin: window -> int -> int -> unit = "curses_mvwin"
external addch: char -> unit = "curses_addch"
external mvwaddch: window -> int -> int -> char -> unit = "curses_mvwaddch"
external addstr: string -> unit = "curses_addstr"
external mvwaddstr: window -> int -> int -> string -> unit = "curses_mvwaddstr"
(* lots more omitted *)
\end{verbatim}
To compile this interface:
\begin{verbatim}
        ocamlc -c curses.mli
\end{verbatim}

To implement these functions, we just have to provide the stub code;
the core functions are already implemented in the "curses" library.
The stub code file, "curses.o", looks like:
\begin{verbatim}
#include <curses.h>
#include <mlvalues.h>

value curses_initscr(value unit)
{
  return (value) initscr();     /* OK to coerce directly from WINDOW * to value
                                   since that's a block created by malloc() */
}

value curses_wrefresh(value win)
{
  wrefresh((WINDOW *) win);
  return Val_unit;
}

value curses_newwin(value nlines, value ncols, value x0, value y0)
{
  return (value) newwin(Int_val(nlines), Int_val(ncols),
                        Int_val(x0), Int_val(y0));
}

value curses_addch(value c)
{
  addch(Int_val(c));            /* Characters are encoded like integers */
  return Val_unit;
}

value curses_addstr(value s)
{
  addstr(String_val(s));
  return Val_unit;
}

/* This goes on for pages. */
\end{verbatim}

The file "curses.c" can be compiled with:
\begin{verbatim}
        cc -c -I/usr/local/lib/ocaml curses.c
\end{verbatim}
or, even simpler,
\begin{verbatim}
        ocamlc -c curses.c
\end{verbatim}
(When passed a ".c" file, the "ocamlc" command simply calls the C
compiler on that file, with the right "-I" option.)

Now, here is a sample Caml program "test.ml" that uses the "curses"
module:
\begin{verbatim}
open Curses
let main_window = initscr () in
let small_window = newwin 10 5 20 10 in
  mvwaddstr main_window 10 2 "Hello";
  mvwaddstr small_window 4 3 "world";
  refresh();
  for i = 1 to 100000 do () done;
  endwin()
\end{verbatim}
To compile this program, run:
\begin{verbatim}
        ocamlc -c test.ml
\end{verbatim}
Finally, to link everything together:
\begin{verbatim}
        ocamlc -custom -o test test.cmo curses.o -cclib -lcurses
\end{verbatim}

\section{Advanced example with callbacks}

This section illustrates the callback facilities described in
section~\ref{s:callback}. We are going to package some Caml functions
in such a way that they can be linked with C code and called from C
just like any C functions. The Caml functions are defined in the
following "mod.ml" Caml source:

\begin{verbatim}
(* File mod.ml -- some ``useful'' Caml functions *)

let rec fib n = if n < 2 then 1 else fib(n-1) + fib(n-2)

let format_result n = Printf.sprintf "Result is: %d\n" n

(* Export those two functions to C *)

let _ = Callback.register "fib" fib
let _ = Callback.register "format_result" format_result
\end{verbatim}

Here is the C stub code for calling these functions from C:

\begin{verbatim}
/* File modwrap.c -- wrappers around the Caml functions */

#include <stdio.h>
#include <string.h>
#include <caml/mlvalues.h>
#include <caml/callback.h>

int fib(int n)
{
  static value * fib_closure = NULL;
  if (fib_closure == NULL) fib_closure = caml_named_value("fib");
  return Int_val(callback(*fib_closure, Val_int(n)));
}

char * format_result(int n)
{
  static value * format_result_closure = NULL;
  if (format_result_closure == NULL)
    format_result_closure = caml_named_value("format_result");
  return strdup(String_val(callback(*format_result_closure, Val_int(n))));
  /* We copy the C string returned by String_val to the C heap
     so that it remains valid after garbage collection. */
}
\end{verbatim}

We now compile the Caml code to a C object file and put it in a C
library along with the stub code in "modwrap.c" and the Caml runtime system:
\begin{verbatim}
        ocamlc -custom -output-obj -o modcaml.o mod.ml
        ocamlc -c modwrap.c
        cp /usr/local/lib/ocaml/libcamlrun.a mod.a
        ar r mod.a modcaml.o modwrap.o
\end{verbatim}
(One can also use "ocamlopt -output-obj" instead of "ocamlc -custom
-output-obj".  In this case, replace "libcamlrun.a" (the bytecode
runtime library) by "libasmrun.a" (the native-code runtime library).)

Now, we can use the two fonctions "fib" and "format_result" in any C
program, just like regular C functions. Just remember to call
"caml_startup" once before.

\begin{verbatim}
/* File main.c -- a sample client for the Caml functions */

#include <stdio.h>

int main(int argc, char ** argv)
{
  int result;

  /* Initialize Caml code */
  caml_startup(argv);
  /* Do some computation */
  result = fib(10);
  printf("fib(10) = %s\n", format_result(result));
  return 0;
}
\end{verbatim}

To build the whole program, just invoke the C compiler as follows:
\begin{verbatim}
        cc -o prog main.c mod.a
\end{verbatim}
