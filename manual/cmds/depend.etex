\chapter{Dependency generator (ocamldep)} \label{c:camldep}

The "ocamldep" command scans a set of Objective Caml source files
(".ml" and ".mli" files) for references to external compilation units,
and outputs dependency lines in a format suitable for the "make"
utility. This ensures that "make" will compile the source files in the
correct order, and recompile those files that need to when a source
file is modified.

The typical usage is:
\begin{alltt}
        ocamldep \var{options} *.mli *.ml > .depend
\end{alltt}
where "*.mli *.ml" expands to all source files in the current
directory and ".depend" is the file that should contain the
dependencies. (See below for a typical "Makefile".)

Dependencies are generated both for compiling with the bytecode
compiler "ocamlc" and with the native-code compiler "ocamlopt".

\section{Options}

The following command-line option is recognized by "ocamldep".

\begin{options}

\item["-I" \var{directory}]
Add the given directory to the list of directories searched for
source files. If a source file "foo.ml" mentions an external
compilation unit "Bar", a dependency on that unit's interface
"bar.cmi" is generated only if the source for "bar" is found in the
current directory or in one of the directories specified with "-I".
Otherwise, "Bar" is assumed to be a module form the standard library,
and no dependencies are generated. For programs that span multiple
directories, it is recommended to pass "ocamldep" the same "-I" options
that are passed to the compiler.

\end{options}

\section{A typical Makefile}

Here is a template "Makefile" for a Objective Caml program.

\begin{verbatim}
CSLC=ocamlc
CSLOPT=ocamlopt
CSLDEP=ocamldep
INCLUDES=               #all relevant -I options here
CSLFLAGS=$(INCLUDES)    #add other options for ocamlc here
CSLOPTFLAGS=$(INCLUDES) #add other options for ocamlopt here

# prog1 should be compiled to bytecode, and is composed of three
# units: mod1, mod2 and mod3.

# The list of object files for prog1
PROG1_OBJS=mod1.cmo mod2.cmo mod3.cmo

prog1: $(PROG1_OBJS)
	$(CSLC) -o prog1 $(CSLFLAGS) $(PROG1_OBJS)

# prog2 should be compiled to native-code, and is composed of two
# units: mod4 and mod5.

# The list of object files for prog2
PROG2_OBJS=mod4.cmx mod5.cmx

prog2: $(PROG2_OBJS)
	$(CSLOPT) -o prog2 $(CSLFLAGS) $(PROG2_OBJS)

# Common rules
.SUFFIXES: .ml .mli .cmo .cmi .cmx

.ml.cmo:
	$(CSLC) $(CSLFLAGS) -c $<

.mli.cmi:
	$(CSLC) $(CSLFLAGS) -c $<

.ml.cmx:
	$(CSLOPT) $(CSLOPTFLAGS) -c $<

# Clean up
clean:
	rm -f prog1 prog2
	rm -f *.cm[iox]

# Dependencies
depend:
        $(CSLDEP) $(INCLUDES) *.mli *.ml > .depend

include .depend
\end{verbatim}

