\chapter{Language extensions} \label{c:extensions}
\pdfchapter{Language extensions}

This chapter describes the language features that are implemented in
Objective Caml, but not described in the Objective Caml
reference manual. In contrast with the fairly stable kernel language
that is described in the reference manual, the extensions presented
here are still experimental, and may be removed or changed in the
future.

\section{Streams and stream parsers}
\label{s:streams}

Objective Caml comprises a library type for {\it streams}
(possibly infinite sequences of elements, that are evaluated on
demand), and associated stream expressions, to build streams, and
stream patterns, to destructure streams. Streams and stream patterns
provide a natural approach to the writing of recursive-descent
parsers.

Streams are presented by the following extensions to the syntactic
classes of expressions:

\ikwd{parser\@\texttt{parser}}
\ikwd{match\@\texttt{match}}
\ikwd{match\@\texttt{when}}

\begin{syntax}
expr:
          \ldots
        | '[<' '>]'
        | '[<' stream-component { ';' stream-component } '>]'
        | 'parser' [pattern] stream-matching
        | 'match' expr 'with' 'parser' [pattern] stream-matching
;
stream-component:
          "'" expr
        | expr
;
stream-matching:
        stream-pattern [pattern] '->' expr
          { '|' stream-pattern [pattern] '->' expr }
;
stream-pattern:
          '[<' '>]'
        | '[<' stream-pat-comp { ';' stream-pat-comp [ '??' expr ] }'>]'
;
stream-pat-comp:
          "'" pattern [ 'when' expr ]
        | pattern '=' expr
        | ident
;
\end{syntax}

Stream expressions are bracketed by \verb"[<" and \verb">]". They
represent the concatenation of their components. The component
@"'" expr@ represents the one-element stream whose element is the
value of @expr@. The component @expr@ represents a
sub-stream. For instance, if both "s" and "t" are streams of integers,
then \verb"[<'1; s; t; '2>]" is a stream of integers containing the
element "1", then the elements of "s", then those of "t", and finally
"2". The empty stream is denoted by \verb"[< >]".

Unlike any other kind of expressions in the language, stream
expressions are submitted to lazy evaluation: the components are not
evaluated when the stream is built, but only when they are accessed
during stream matching. The components are evaluated once, the first
time they are accessed; the following accesses reuse the value
computed the first time.

Stream patterns, also bracketed by \verb"[<" and \verb">]", describe
initial segments of streams. In particular, the stream pattern
\verb"[< >]" matches all streams. Stream pattern components are
matched against the corresponding elements of a stream. The component
@"'" pattern@ matches the corresponding stream element against the
pattern; if followed by @when@, the match is accepted only if the
result of the guard expression is "true". The component @pattern '='
expr@ applies the function denoted by @expr@ to the current stream,
then matches the result of the function against @pattern@. Finally,
the component @ident@ simply binds the identifier to the stream being
matched.

Stream matching proceeds destructively: once a component has been
matched, it is discarded from the stream (by in-place modification).

Stream matching proceeds in two steps: first, a pattern is selected by
matching the stream against the first components of the stream
patterns; then, the following components of the selected pattern are
checked against the stream. If the following components do not match,
the exception "Stream.Error" is raised. There is no backtracking
here: stream matching commits to the pattern selected according to the
first element. If none of the first components of the stream patterns
match, the exception "Stream.Failure" is raised. The
"Stream.Failure" exception causes the next alternative to be
tried, if it occurs during the matching of the first element of a
stream, before matching has committed to one pattern.

The streams hold the count of their elements discarded. The optional
@pattern@ before the first stream pattern is bound to the stream
count before the matching. The one after each stream pattern
(optional, too) is bound to the stream count after the matching.

The exception "Stream.Error" has a string parameter coming from the
optional @'??' expr@ after the stream pattern components (its default
is the empty string). This expression is evaluated only in case of
error.

See {\em Functional programming using Caml Light} for a more gentle
introductions to streams, and for some examples of their use in
writing parsers. A more formal presentation of streams, and a
discussion of alternate semantics, can be found in {\em Parsers in ML}
by Michel Mauny and Daniel de Rauglaudre, in the proceedings of the
1992 ACM conference on Lisp and Functional Programming.

\section{Range patterns}

In patterns, Objective Caml recognizes the form
@"'" c "'" ".." "'" d "'"@
(two character literals separated by~"..") as shorthand for the pattern
\begin{center}
@"'" c "'" "|" "'" c_1 "'" "|" "'" c_2 "'" "|" \ldots
        "|" "'" c_n "'" "|" "'" d "'"@
\end{center}
where \nth{c}{1}, \nth{c}{2}, \ldots, \nth{c}{n} are the characters
that occur between \var{c} and \var{d} in the ASCII character set. For
instance, the pattern "'0'..'9'" matches all characters that are digits.

\section{Assertion checking}
\ikwd{assert\@\texttt{assert}}

Objective Caml supports the "assert" construct to check debugging assertions.
The expression @"assert" expr@ evaluates the expression @expr@ and
returns "()" if @expr@ evaluates to "true".  Otherwise, the exception
"Assert_failure" is raised with the source file name and the
location of @expr@ as arguments.  Assertion
checking can be turned off with the "-noassert" compiler option.

As a special case, "assert false" is reduced to
"raise (Assert_failure ...)", which is polymorphic (and
is not turned off by the "-noassert" option).
%
\index{Assert_failure (exception)\@\verb`Assert_failure` (exception)}


\section{Deferred computations}
\ikwd{lazy\@\texttt{lazy}}

The expression @"lazy" expr@ returns a value \var{v} of type "Lazy.t" that
encapsulates the computation of @expr@.  The argument @expr@ is not
evaluated at this point in the program.  Instead, its evaluation will
be performed the first time "Lazy.force" is applied to the value
\var{v}, returning the actual value of @expr@. Subsequent applications
of "Lazy.force" to \var{v} do not evaluate @expr@ again.

The expression @"lazy" expr@ is equivalent to
@"ref"("Lazy.Delayed"("fun" "()" "->" expr))@.
For more information, see the description of module "Lazy" in the
standard library (section~\ref{s:Lazy}).
%
\index{Lazy (module)\@\verb`Lazy` (module)}%
\index{force\@\verb`force`}%

\section{Local modules}
\ikwd{let\@\texttt{let}}
\ikwd{module\@\texttt{module}}

The expression
@"let" "module" module-name "=" module-expr "in" expr@
locally binds the module expression @module-expr@ to the identifier
@module-name@ during the evaluation of the expression @expr@.
It then returns the value of @expr@.  For example:
\begin{verbatim}
        let remove_duplicates comparison_fun string_list =
          let module StringSet =
            Set.Make(struct type t = string
                            let compare = comparison_fun end) in
          StringSet.elements
            (List.fold_right StringSet.add string_list StringSet.empty)
\end{verbatim}

