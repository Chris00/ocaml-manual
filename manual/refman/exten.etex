\chapter{Language extensions} \label{c:extensions}
\pdfchapter{Language extensions}

This chapter describes the language features that are implemented in
Objective Caml, but not described in the Objective Caml
reference manual. In contrast with the fairly stable kernel language
that is described in the reference manual, the extensions presented
here are still experimental, and may be removed or changed in the
future.

\section{Streams and stream parsers}
\label{s:streams}

Streams and stream parsers are no longer part of the Objective Caml
language, but available through a CamlP4 syntax extension.  See the
CamlP4 reference manual for more information.  Objective Caml programs
that use streams and stream parsers can be compiled with the
"-pp camlp4o" option to "ocamlc" and "ocamlopt".  For interactive use,
run "ocaml" and issue the \verb'#load "camlp4o.cma";;' command.

\section{Range patterns}

In patterns, Objective Caml recognizes the form
@"'" c "'" ".." "'" d "'"@
(two character literals separated by~"..") as shorthand for the pattern
\begin{center}
@"'" c "'" "|" "'" c_1 "'" "|" "'" c_2 "'" "|" \ldots
        "|" "'" c_n "'" "|" "'" d "'"@
\end{center}
where \nth{c}{1}, \nth{c}{2}, \ldots, \nth{c}{n} are the characters
that occur between \var{c} and \var{d} in the ASCII character set. For
instance, the pattern "'0'..'9'" matches all characters that are digits.

\section{Assertion checking}
\ikwd{assert\@\texttt{assert}}

Objective Caml supports the "assert" construct to check debugging assertions.
The expression @"assert" expr@ evaluates the expression @expr@ and
returns "()" if @expr@ evaluates to "true".  Otherwise, the exception
"Assert_failure" is raised with the source file name and the
location of @expr@ as arguments.  Assertion
checking can be turned off with the "-noassert" compiler option.

As a special case, "assert false" is reduced to
"raise (Assert_failure ...)", which is polymorphic (and
is not turned off by the "-noassert" option).
%
\index{Assert_failure (exception)\@\verb`Assert_failure` (exception)}


\section{Deferred computations}
\ikwd{lazy\@\texttt{lazy}}

The expression @"lazy" expr@ returns a value \var{v} of type "Lazy.t" that
encapsulates the computation of @expr@.  The argument @expr@ is not
evaluated at this point in the program.  Instead, its evaluation will
be performed the first time "Lazy.force" is applied to the value
\var{v}, returning the actual value of @expr@. Subsequent applications
of "Lazy.force" to \var{v} do not evaluate @expr@ again.

The expression @"lazy" expr@ is equivalent to
@"ref"("Lazy.Delayed"("fun" "()" "->" expr))@.
For more information, see the description of module "Lazy" in the
standard library (
\ifouthtml
 \begin{rawhtml}<a HREF=libref/Lazy.html>Module <tt>Lazy</tt></a>
 \end{rawhtml}
\else
section~\ref{Lazy}
\fi).
%
\index{Lazy (module)\@\verb`Lazy` (module)}%
\index{force\@\verb`force`}%

\section{Local modules}
\ikwd{let\@\texttt{let}}
\ikwd{module\@\texttt{module}}

The expression
@"let" "module" module-name "=" module-expr "in" expr@
locally binds the module expression @module-expr@ to the identifier
@module-name@ during the evaluation of the expression @expr@.
It then returns the value of @expr@.  For example:
\begin{verbatim}
        let remove_duplicates comparison_fun string_list =
          let module StringSet =
            Set.Make(struct type t = string
                            let compare = comparison_fun end) in
          StringSet.elements
            (List.fold_right StringSet.add string_list StringSet.empty)
\end{verbatim}

\section{Grouping in integer and floating-point literals}

In integer and floating-point literals, the character "_" (underscore)
can be used to separate groups of digits, as in "1_000_000",
"0x45_FF",  or "1_234.567_89".  The underscore characters are simply
ignored when reading the literal.
