\section{Type and exception definitions}
\pdfsection{Type and exception definitions}

\subsection{Type definitions}
\label{s:type-defs}

Type definitions bind type constructors to data types: either
variant types, record types, type abbreviations, or abstract data
types. They also bind the value constructors and record labels
associated with the definition.

\ikwd{type\@\texttt{type}}

\begin{syntax}
type-definition:
          'type' typedef { 'and' typedef }
;
typedef:
          [type-params] typeconstr-name [type-equation] [type-representation]
          { type-constraint }
;
type-equation:
          '=' typexpr
;
type-representation:
          '=' constr-decl { '|' constr-decl }
        | '=' '{' label-decl { ';' label-decl } '}'
;
type-params:
          "'" ident
        | '(' "'" ident { "," "'" ident } ')'
;
constr-decl:
          cconstr-name
        | ncconstr-name 'of' typexpr
;
label-decl:
          label-name ':' typexpr
        | 'mutable' label-name ':' typexpr
;
type-constraint:
    'constraint' "'" ident '=' typexpr
;
\end{syntax}
\ikwd{mutable\@\texttt{mutable}}
\ikwd{constraint\@\texttt{constraint}}

Type definitions are introduced by the "type" keyword, and
consist in one or several simple definitions, possibly mutually
recursive, separated by the "and" keyword. Each simple definition
defines one type constructor.

A simple definition consists in a lowercase identifier, possibly
preceded by one or several type parameters, and followed by an
optional type equation, then an optional type representation, and then
a constraint clause. The identifier is the name of the type
constructor being defined.

The optional type parameters are either one type variable @"'" ident@,
for type constructors with one parameter, or a list of type variables
@("'"ident_1,\ldots,"'"ident_n)@, for type constructors with several
parameters. These type parameters can appear in the type expressions
of the right-hand side of the definition.

The optional type equation @'=' typexpr@ makes the defined type
equivalent to the type expression @typexpr@ on the right of the @'='@
sign: one can be substituted  for the other during typing.
If no type equation is given, a new type is generated: the defined type
is incompatible with any other type.

The optional type representation describes the data structure
representing the defined type, by giving the list of associated
constructors (if it is a variant type) or associated labels (if it is
a record type). If no type representation is given, nothing is
assumed on the structure of the type besides what is stated in the
optional type equation.

The type representation @'=' constr-decl { '|' constr-decl }@
describes a variant type. The constructor declarations
@constr-decl_1, \ldots, constr-decl_n@ describe the constructors
associated to this variant type. The constructor
declaration @ncconstr-name 'of' typexpr@ declares the name
@ncconstr-name@ as a non-constant constructor, whose
argument has type @typexpr@. The constructor declaration @cconstr-name@
declares the name @cconstr-name@ as a constant
constructor. Constructor names must be capitalized.

The type representation @'=' '{' label-decl { ';' label-decl } '}'@
describes a record type. The label declarations @label-decl_1, \ldots,
label-decl_n@ describe the labels associated to this record type.
The label declaration @label-name ':' typexpr@ declares @label-name@
as a label whose argument has type @typexpr@.
The label declaration @'mutable' label-name ':' typexpr@
\ikwd{mutable\@\texttt{mutable}}
behaves similarly; in addition, it allows physical modification over
the argument to this label.

The two components of a type definition, the optional equation and the
optional representation, can be combined independently, giving
rise to four typical situations:

\begin{description}
\item[Abstract type: no equation, no representation.] ~\\
When appearing in a module signature, this definition specifies
nothing on the type constructor, besides its number of parameters: 
its representation is hidden and it is assumed incompatible with any
other type.

\item[Type abbreviation: an equation, no representation.] ~\\
This defines the type constructor as an abbreviation for the type
expression on the right of the @'='@ sign. 

\item[New variant type or record type: no equation, a representation.] ~\\
This generates a new type constructor and defines associated
constructors or labels, through which values of that type can be
directly built or inspected.

\item[Re-exported variant type or record type: an equation,
a representation.] ~\\
In this case, the type constructor is defined as an abbreviation for
the type expression given in the equation, but in addition the
constructors or labels given in the representation remain attached to
the defined type constructor. The type expression in the equation part
must agree with the representation: it must be of the same kind
(record or variant) and have exactly the same constructors or labels,
in the same order, with the same arguments. 
\end{description}

\ikwd{constraint\@\texttt{constraint}}
The construct @ 'constraint' "'" ident '=' typexpr @ allows to specify
type parameters.  Any actual type argument corresponding to the type
parameter @ident@ have to be an instance of @typexpr@ (more precisely,
@ident@ and @typexpr@ are unified). Type variables of @typexpr@ can
appear in the type equation and the type declaration.

\subsection{Exception definitions} \label{s:excdef}
\ikwd{exception\@\texttt{exception}}

\begin{syntax}
exception-definition:
        'exception' constr-decl
\end{syntax}

Exception definitions add new constructors to the built-in variant
type \verb"exn" of exception values. The constructors are declared as
for a definition of a variant type.
