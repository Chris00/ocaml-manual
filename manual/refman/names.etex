\section{Names} \label{s:names}
\pdfsection{Names}

Identifiers are used to give names to several classes of language
objects and refer to these objects by name later:
\begin{itemize}
\item value names (syntactic class @value-name@),
\item value constructors (constant -- class @cconstr-name@ -- or
non-constant -- class @ncconstr-name@),
\item variant tags (@tag-name@),
\item type constructors (@typeconstr-name@),
\item record fields (@field-name@),
\item class names (@class-name@),
\item method names (@method-name@),
\item instance variable names (@inst-var-name@),
\item module names (@module-name@),
\item module type names (@modtype-name@).
\end{itemize}
These nine name spaces are distinguished both by the context and by the
capitalization of the identifier: whether the first letter of the
identifier is in lowercase (written @lowercase-ident@ below) or in
uppercase (written @capitalized-ident@).  Underscore is considered a
lowercase letter for this purpose.

\ikwd{false\@\texttt{false}}
\ikwd{true\@\texttt{true}}

\subsubsection*{Naming objects}

\begin{syntax}
value-name:
        lowercase-ident
      | '(' operator-name ')'
;
operator-name:
        prefix-symbol || infix-symbol || '*' || '=' || 'or' || '&' || ':='
;
cconstr-name:
        capitalized-ident
      | 'false'
      | 'true'
      | '[' ']'
      | '(' ')'
;
ncconstr-name:
        capitalized-ident
      | '::'
;
tag-name:
        capitalized-ident
;
typeconstr-name:
        lowercase-ident
;
field-name:
        lowercase-ident
;
module-name:
        capitalized-ident
;
modtype-name:
        ident
;
class-name:
    lowercase-ident
;
inst-var-name:
    lowercase-ident
;
method-name:
    lowercase-ident
\end{syntax}
As shown above, prefix and infix symbols as well as some keywords can
be used as value names, provided they are written between parentheses.
Keywords such as '::' and 'false' are also constructor names. The
capitalization rules  are summarized in the table
below.

\begin{tableau}{|l|l|}{Name space}{Case of first letter}
\entree{Values}{lowercase}
\entree{Constructors}{uppercase}
\entree{Variant tag}{uppercase}
\entree{Type constructors}{lowercase}
\entree{Record fields}{lowercase}
\entree{Classes}{lowercase}
\entree{Methods}{lowercase}
\entree{Modules}{uppercase}
\entree{Module types}{any}
\end{tableau}

\subsubsection*{Referring to named objects}

\begin{syntax}
value-path:
        value-name
      | module-path '.' lowercase-ident
;
cconstr:
        cconstr-name
      | module-path '.' capitalized-ident
;
ncconstr:
        ncconstr-name
      | module-path '.' capitalized-ident
;
typeconstr:
        typeconstr-name
      | extended-module-path '.' lowercase-ident
;
field:
        field-name
      | module-path '.' lowercase-ident
;
module-path:
        module-name
      | module-path '.' capitalized-ident
;
extended-module-path:
        module-name
      | extended-module-path '.' capitalized-ident
      | extended-module-path '(' extended-module-path ')'
;
modtype-path:
        modtype-name
      | extended-module-path '.' ident
;
class-path:
    class-name
  | module-path '.' lowercase-ident
\end{syntax}

A named object can be referred to either by its name (following the
usual static scoping rules for names) or by an access path @prefix '.' name@,
where @prefix@ designates a module and @name@ is the name of an object
defined in that module. The first component of the path, @prefix@, is
either a simple module name or an access path @name_1 '.' name_2 \ldots@,
in case the defining module is itself nested inside other modules.
For referring to type constructors or module types, the @prefix@ can
also contain simple functor applications (as in the syntactic class
@extended-module-path@ above), in case the defining module is the
result of a functor application.

Instance variable names, tag names and method names need not be
qualified: the former are local to a class while the two latter are
global labels.
