\section{Module types (module specifications)}

Module types are the module-level equivalent of type expressions: they
specify the general shape and type properties of modules.

\ikwd{sig\@\verb`sig`}
\ikwd{end\@\verb`end`}
\ikwd{functor\@\verb`functor`}
\ikwd{with\@\verb`with`}
\ikwd{val\@\verb`val`}
\ikwd{external\@\verb`external`}
\ikwd{type\@\verb`type`}
\ikwd{exception\@\verb`exception`}
\ikwd{module\@\verb`module`}
\ikwd{open\@\verb`open`}

\begin{syntax}
module-type:
          modtype-path
        | 'sig' { specification [';;'] } 'end'
        | 'functor' '(' module-name ':' module-type ')' '->' module-type
        | module-type 'with' typedef { 'and' typedef }
        | '(' module-type ')'
;
specification:
          'val' value-name ':' typexpr
        | 'external' value-name ':' typexpr '=' external-declaration
        | type-definition
        | exception-definition
        | 'module' module-name ':' module-type
        | 'module' module-name { '(' module-name ':' module-type ')' }
          ':' module-type
        | 'module' 'type' modtype-name
        | 'module' 'type' modtype-name '=' module-type
        | 'open' module-path
\end{syntax}

\subsection{Simple module types}

The expression @modtype-path@ is equivalent to the module type bound
to the name @modtype-path@.
The expression @'(' module-type ')'@ denotes the same type as
@module-type@.

\subsection{Signatures}

\ikwd{sig\@\verb`sig`}
\ikwd{end\@\verb`end`}

Signatures are type specifications for structures. Signatures
@'sig' \ldots 'end'@ are collections of type specifications for value
names, type names, exceptions, module names and module type names. A
structure will match a signature if the structure provides definitions
(implementations) for all the names specified in the signature (and
possibly more), and these definitions meet the type requirements given
in the signature.

For compatibility with Caml Light, an optional ";;" is allowed after each
specification in a signature. The ";;" has no semantic meaning.

\subsubsection*{Value specifications}

\ikwd{val\@\verb`val`}

A specification of a value component in a signature is written
@'val' value-name ':' typexpr@, where @value-name@ is the name of the
value and @typexpr@ its expected type.

\ikwd{external\@\verb`external`}

The form @'external' value-name ':' typexpr '=' external-declaration@
is similar, except that it requires in addition the name to be
implemented as the external function specified in @external-declaration@
(see chapter~\ref{c:intf-c}).

\subsubsection*{Type specifications}

\ikwd{type\@\verb`type`}

A specification of one or several type components in a signature is
written @'type' typedef { 'and' typedef }@ and consists of a sequence
of mutually recursive definitions of type names.

Names that are defined as abstract types in a signature can be
implemented in a matching structure by any kind of type definition
(provided it has the same number of type parameters). The exact
implementation of the type will be hidden to the users of the
structure. In particular, if the type is implemented as a variant type
or record type, the associated constructors and labels will not be
accessible to the users; if the type is implemented as an
abbreviation, the type equality between the type name and the
right-hand side of the abbreviation will be hidden from the users of the
structure.

In contrast, type names that are defined as variant types, record
types or type abbreviations in a signature are manifest type
specifications: any matching structure must implement these type names
exactly as defined in the signature; the concrete representation of
these types is visible to all users of the structure, including the
constructors introduced by variant types, the labels introduced by
record types, and the type equalities introduced by abbreviations.

\subsubsection*{Exception specification}

\ikwd{external\@\verb`external`}

The specification @'exception' constr-decl@ in a signature requires the
matching structure to provide an exception with the name and arguments
specified in the definition, and makes the exception available to all
users of the structure.

\subsubsection*{Module specifications}

\ikwd{module\@\verb`module`}

A specification of a module component in a signature is written
@'module' module-name ':' module-type@, where @module-name@ is the
name of the module component and @module-type@ its expected type.
Modules can be nested arbitrarily; in particular, functors can appear
as components of structures and functor types as components of
signatures.

For specifying a module component that is a functor, one may write
\begin{center}
@'module' module-name '(' name_1 ':' module-type_1 ')'
               \ldots '(' name_n ':' module-type_n ')'
          ':' module-type@
\end{center}
instead of
\begin{center}
@'module' module-name ':'
 'functor' '(' name_1 ':' module-type_1 ')' '->' \ldots
                                            '->' module-type@
\end{center}

\subsubsection*{Module type specifications}

\ikwd{type\@\verb`type`}
\ikwd{module\@\verb`module`}

A module type component of a signature can be specified either as a
manifest module type or as an abstract module type.

An abstract module type specification
@'module' 'type' modtype-name@ allows the name @modtype-name@ to be
implemented by any module type in a matching signature, but hides the
implementation of the module type to all users of the signature.

A manifest module type specification
@'module' 'type' modtype-name '=' module-type@
requires the name @modtype-name@ to be implemented by the module type
@module-type@ in a matching signature, but makes the equality between
@modtype-name@ and @module-type@ apparent to all users of the signature.

\subsubsection{Opening a module path}

\ikwd{open\@\verb`open`}

The expression @'open' module-path@ in a signature does not specify
any components. It simply affects the parsing of the following items
of the signature, allowing components of the module denoted by
@module-path@ to be referred to by their simple names @name@ instead of
path accesses @module-path '.' name@. The scope of the "open"
stops at the end of the signature expression.

\subsection{Functor types}

\ikwd{functor\@\verb`functor`}

The module type expression 
@'functor' '(' module-name ':' module-type_1 ')' '->' module-type_2@ 
is the type of functors (functions from modules to modules) that take
as argument a module of type @module-type_1@ and return as result a
module of type @module-type_2@. The module type @module-type_2@ can
use the name @module-name@ to refer to type components of the actual
argument of the functor. No restrictions are placed on the type of the
functor argument; in particular, a functor may take another functor as
argument (``higher-order'' functor).

\subsection{The "with" operator}

\ikwd{with\@\verb`with`}

Assuming @module-type@ denotes a signature, the expression
@module-type 'with' typedef { 'and' typedef }@ denotes the same
signature where some of the abstract type specifications have been
replaced by more precise specifications, as indicated by the type
definitions following the "with" keyword.

For instance, if the module type name "S" is bound to the signature
"sig type t type u end", then
"S with type t=int" denotes the signature "sig type t=int type u end"
and
"S with type u=A|B" denotes the signature "sig type t type u=A|B end".
A functor taking two arguments of type "S" such that the "u" component
of the second argument shares with the "t" component of the first
argument is written
\begin{verbatim}
        functor (A: S) (B: S with u = A.t) ...
\end{verbatim}
