\section{Type expressions}
\pdfsection{Type expressions}

\ikwd{as\@\texttt{as}}

\begin{syntax}
typexpr:
        "'" ident
      | '(' typexpr ')'
      | typexpr '->' typexpr
      | typexpr {{ '*' typexpr }}
      | typeconstr
      | typexpr typeconstr
      | '(' typexpr { ',' typexpr } ')' typeconstr
      | typexpr 'as' "'" ident
      | '<' ['..'] '>'
      | '<' method-type { ';' method-type } [';' '..'] '>'
      | '#' class-path
      | typexpr '#' class-path
      | '(' typexpr { ',' typexpr } ) '#' class-path
;
method-type:
    method-name ':' typexpr
\end{syntax}

The table below shows the relative precedences and associativity of
operators and non-closed type constructions. The constructions with
higher precedences come first.
\ikwd{as\@\texttt{as}}
\begin{tableau}{|l|l|}{Operator}{Associativity}
\entree{Type constructor application}{--}
\entree{"*"}{--}
\entree{"->"}{right}
\entree{"as"}{--}
\end{tableau}

Type expressions denote types in definitions of data types as well as
in type constraints over patterns and expressions.

\subsubsection*{Type variables}

The type expression @"'" ident@ stands for the type variable named
@ident@. In data type definitions, type variables are names for the
data type parameters. In type constraints, they represent unspecified
types that can be instantiated by any type to satisfy the type
constraint.

\subsubsection*{Parenthesized types}

The type expression @"(" typexpr ")"@ denotes the same type as
@typexpr@.

\subsubsection*{Function types}

The type expression @typexpr_1 '->' typexpr_2@ denotes the type of
functions mapping arguments of type @typexpr_1@ to results of type
@typexpr_2@.

\subsubsection*{Tuple types}

The type expression @typexpr_1 '*' \ldots '*' typexpr_n@
denotes the type of tuples whose elements belong to types @typexpr_1,
\ldots typexpr_n@ respectively.

\subsubsection*{Constructed types}

Type constructors with no parameter, as in @typeconstr@, are type
expressions.

The type expression @typexpr typeconstr@, where @typeconstr@ is a type
constructor with one parameter, denotes the application of the unary type
constructor @typeconstr@ to the type @typexpr@.

The type expression @(typexpr_1,\ldots,typexpr_n) typeconstr@, where
@typeconstr@ is a type constructor with $n$ parameters, denotes the
application of the $n$-ary type constructor @typeconstr@ to the types
@typexpr_1@ through @typexpr_n@.

\subsubsection*{Recursive types}

\ikwd{as\@\texttt{as}}

The type expression @typexpr 'as' "'" ident@ denotes the same type as
@typexpr@, and also binds the type variable @ident@ to type @typexpr@
both in @typexpr@ and in the remaining part of the type. 
If the type variable @ident@ actually occurs in @typexpr@, a recursive
type is created. Recursive types are only allowed when any recursion
crosses an object type.
%

\subsubsection*{Object types}

An object type
@'<' method-type { ';' method-type } '>'@
is a record of method types.

The type @'<' method-type { ';' method-type } ';' '..'  '>'@ is the
type of an object with methods and their associated types are described by
@method-type_1, \ldots, method-type_n@, and possibly some other
methods represented by the ellipsis.  This ellipsis actually is
a special kind of type variable, named row variable.

\subsubsection*{\#-types}
\label{s:sharp-types}

The type @'#' class-path@ is a special kind of abbreviation. This
abbreviation unifies with the type of any object belonging to a subclass
of class @class-path@.
%
It is handled in a special way as it usually hides a type variable (an
ellipsis, representing the methods that may be added in a subclass).
In particular, it vanishes when the ellipsis gets instantiated.
%
Each type expression @'#' class-path@ defines a new type variable, so
type @'#' class-path '->' '#' class-path@ is usually not the same as
type @'#' class-path 'as' "'" ident '->' "'" ident@.
%
