\section{Expressions} \label{s:value-expr}
\ikwd{in\@\verb`in`|see{\verb`let`}}
\ikwd{and\@\verb`and`|see{\verb`let`, \verb`type`}}
\ikwd{rec\@\verb`rec`|see{\verb`let`}}
\ikwd{let\@\verb`let`}
\ikwd{try\@\verb`try`}
\ikwd{function\@\verb`function`}
\ikwd{fun\@\verb`fun`}
\ikwd{with\@\verb`with`|see{\verb`match`, \verb`try`}}
\ikwd{done\@\verb`done`|see{\verb`while`, \verb`for`}}
\ikwd{do\@\verb`do`|see{\verb`while`, \verb`for`}}
\ikwd{downto\@\verb`downto`|see{\verb`for`}}
\ikwd{to\@\verb`to`|see{\verb`for`}}
\ikwd{for\@\verb`for`}
\ikwd{else\@\verb`else`|see{\verb`if`}}
\ikwd{then\@\verb`then`|see{\verb`if`}}
\ikwd{if\@\verb`if`}
\ikwd{of\@\verb`of`|see{\verb`type`, \verb`exception`}}
\ikwd{or\@\verb`or`}
\ikwd{match\@\verb`match`}
\ikwd{begin\@\verb`begin`}
\ikwd{end\@\verb`end`}
\ikwd{when\@\verb`when`}
\ikwd{new\@\verb`new`}

\begin{syntax}
expr:
    value-path
  | constant
  | '(' expr ')'
  | 'begin' expr 'end'
  | '(' expr ':' typexpr ')'
  | expr ',' expr { ',' expr }
  | ncconstr expr
  | expr '::' expr
  | '[' expr { ';' expr } ']'
  | '[|' expr { ';' expr } '|]'
  | '{' label '=' expr { ';' label '=' expr } '}'
  | expr expr
  | prefix-symbol expr
  | expr infix-op expr
  | expr '.' label
  | expr '.' label '<-' expr
  | expr '.(' expr ')'
  | expr '.(' expr ')' '<-' expr
  | expr '.[' expr ']'
  | expr '.[' expr ']' '<-' expr
  | 'if' expr 'then' expr [ 'else' expr ]
  | 'while' expr 'do' expr 'done'
  | 'for' ident '=' expr ( 'to' || 'downto' ) expr 'do' expr 'done'
  | expr ';' expr
  | 'match' expr 'with' pattern-matching
  | 'function' pattern-matching
  | 'fun' multiple-matching
  | 'try' expr 'with' pattern-matching
  | 'let' ['rec'] let-binding  { 'and' let-binding } 'in' expr
  | 'new' class-path
  | expr '#' method-name
  | '(' expr ':>' typexpr ')'
  | '(' expr ':' typexpr ':>' typexpr ')'
;
pattern-matching:
    pattern ['when' expr] '->' expr
    { '|' pattern ['when' expr] '->' expr }
;
multiple-matching:
    {{ pattern }} ['when' expr] '->' expr
;
;
let-binding:
    pattern '=' expr
  | value-name {{ pattern }} [':' typexpr] '=' expr
;
infix-op:
    infix-symbol
  | '*' || '=' || 'or' || '&'
\end{syntax}

The table below shows the relative precedences and associativity of
operators and non-closed constructions. The constructions with higher
precedence come first. For infix and prefix symbols, we write
``"*"\ldots'' to mean ``any symbol starting with "*"''.
\ikwd{not\@\verb`not`}%
\ikwd{or\@\verb`or`}%
\ikwd{if\@\verb`if`}%
\ikwd{fun\@\verb`fun`}%
\ikwd{function\@\verb`function`}%
\ikwd{match\@\verb`match`}%
\ikwd{try\@\verb`try`}%
\ikwd{let\@\verb`let`}%
\begin{tableau}{|l|l|}{Construction or operator}{Associativity}
\entree{prefix-symbol}{--}
\entree{".   .(    .["}{--}
\entree{function application}{right}
\entree{constructor application}{--}
\entree{"-   -." (prefix)}{--}
\entree{"**"\ldots}{right}
\entree{"*"\ldots"   /"\ldots"   %"\ldots"   mod"}{left}
\entree{"+"\ldots"   -"\ldots}{left}
\entree{"::"}{right}
\entree{{\tt \char64} "^"}{right}
\entree{comparisons ("=  ==  < " etc.), all other infix symbols}{left}
\entree{"not"}{--}
\entree{"&   &&"}{left}
\entree{"or  ||"}{left}
\entree{","}{--}
\entree{"<-   :="}{right}
\entree{"if"}{--}
\entree{";"}{right}
\entree{"let  match  fun  function  try"}{--}
\end{tableau}

\subsection{Basic expressions}

\subsubsection*{Constants}

Expressions consisting in a constant evaluate to this constant.

\subsubsection*{Value paths} \label{expr:var}

Expressions consisting in an access path evaluate to the value bound to
this path in the current evaluation environment. The path can
be either a value name or an access path to a value component of a module.

\subsubsection*{Parenthesized expressions}
\ikwd{begin\@\verb`begin`}
\ikwd{end\@\verb`end`}

The expressions @'(' expr ')'@ and @'begin' expr 'end'@ have the same
value as @expr@. Both constructs are semantically equivalent, but it
is good style to use @'begin' \ldots 'end'@ inside control structures:
\begin{alltt}
        if \ldots then begin \ldots ; \ldots end else begin \ldots ; \ldots end
\end{alltt}
and @'(' \ldots ')'@ for the other grouping situations.

Parenthesized expressions can contain a type constraint, as in @'('
expr ':' type ')'@. This constraint forces the type of @expr@ to be
compatible with @type@.

Parenthesized expressions can also contain coercions @'(' expr [':' type] ':>' type')'@ (see subsection~\ref{s:objects} below).


\subsubsection*{Function application}

Function application is denoted by juxtaposition of expressions. The
expression @expr_1 expr_2 \ldots expr_n@ evaluates the expressions
@expr_1@ to @expr_n@. The expression @expr_1@ must evaluate to a
functional value, which is then applied to the values of 
@expr_2, \ldots, expr_n@. The order in which the expressions @expr_1, \ldots,
expr_n@ are evaluated is not specified.

\subsubsection*{Function definition}

Two syntactic forms are provided to define functions. The first form
is introduced by the keyword "function":
\ikwd{function\@\verb`function`}
\begin{latexonly}
$$\begin{array}{rlll}
\token{function} & {\sl pattern}_1 & \token{->} & {\sl expr}_1 \\
\token{|}   & \ldots \\
\token{|}   & {\sl pattern}_n & \token{->} & {\sl expr}_n
\end{array}$$
\end{latexonly}
\begin{rawhtml}
<pre>
function <i>pattern</i>1 -&gt; <i>expr</i>1
       | ...
       | <i>pattern</i>N -&gt; <i>expr</i>N
</pre>
\end{rawhtml}
This expression evaluates to a functional value with one argument.
When this function is applied to a value \var{v}, this value is
matched against each pattern @pattern_1@ to @pattern_n@.
If one of these matchings succeeds, that is, if the value \var{v}
matches the pattern @pattern_i@ for some \var{i},
then the expression @expr_i@ associated to the selected pattern
is evaluated, and its value becomes the value of the function
application. The evaluation of @expr_i@ takes place in an
environment enriched by the bindings performed during the matching.

If several patterns match the argument \var{v}, the one that occurs
first in the function definition is selected. If none of the patterns
matches the argument, the exception "Match_failure" is raised.
%
\index{Match_failure (exception)\@\verb`Match_failure` (exception)}

\medskip

The other form of function definition is introduced by the keyword "fun":
\ikwd{fun\@\verb`fun`}
\begin{center}
@"fun" pattern_1 \ldots pattern_n "->" expr@
\end{center}
This expression is equivalent to:
\begin{center}
@"function" pattern_1 "->" \ldots "function" pattern_n "->" expr@
\end{center}
That is, the "fun" expression above evaluates to a curried function
with \var{n} arguments: after applying this function $n$ times to the
values \nth{v}{1}~\ldots~\nth{v}{m}, the values will be matched
in parallel against the patterns @pattern_1 \ldots pattern_n@.
If the matching succeeds, the function returns the value of @expr@ in
an environment enriched by the bindings performed during the matchings.
If the matching fails, the exception "Match_failure" is raised.

\subsubsection*{Guards in pattern-matchings}

\ikwd{when\@\verb`when`}
Cases of a pattern matching (in the "function", "fun", "match" and
"try" constructs) can include guard expressions, which are
arbitrary boolean expressions that must evaluate to "true" for the
match case to be selected. Guards occur just before the "->" token and
are introduced by the "when" keyword:
\begin{latexonly}
$$\begin{array}{rlll}
\token{function} & {\sl pattern}_1 \; [\token{when} \; {\sl cond}_1] & \token{->} & {\sl expr}_1 \\
\token{|}   & \ldots \\
\token{|}   & {\sl pattern}_n  \; [\token{when} \; {\sl cond}_n] & \token{->} & {\sl expr}_n
\end{array}$$
\end{latexonly}
\begin{rawhtml}
<pre>
function <i>pattern</i>1 [when <i>cond</i>1] -&gt; <i>expr</i>1
       | ...
       | <i>pattern</i>N [when <i>cond</i>N] -&gt; <i>expr</i>N
</pre>
\end{rawhtml}
Matching proceeds as described before, except that if the value
matches some pattern @pattern_i@ which has a guard @cond_i@, then the
expression @cond_i@ is evaluated (in an environment enriched by the
bindings performed during matching). If @cond_i@ evaluates to "true",
then @expr_i@ is evaluated and its value returned as the result of the
matching, as usual. But if @cond_i@ evaluates to "false", the matching
is resumed against the patterns following @pattern_i@.

\subsubsection*{Local definitions} \label{s:localdef}

\ikwd{let\@\verb`let`}

The {\tt let} and {\tt let rec} constructs bind value names locally.
The construct
\begin{center}
@"let" pattern_1 "=" expr_1 "and" \ldots "and" pattern_n "=" expr_n "in" expr@
\end{center}
evaluates @expr_1 \ldots expr_n@ in some unspecified order, then matches
their values against the patterns @pattern_1 \ldots pattern_n@. If the
matchings succeed, @expr@ is evaluated in the environment enriched by
the bindings performed during matching, and the value of @expr@ is
returned as the value of the whole {\tt let} expression. If one of the
matchings fails, the exception "Match_failure" is raised.
%
\index{Match_failure (exception)\@\verb`Match_failure` (exception)}

An alternate syntax is provided to bind variables to functional
values: instead of writing
\begin{center}
@"let" ident "=" "fun" pattern_1 \ldots pattern_m "->" expr@
\end{center}
in a {\tt let} expression, one may instead write
\begin{center}
@"let" ident pattern_1 \ldots pattern_m "=" expr@
\end{center}

\medskip
\noindent
Recursive definitions of names are introduced by {\tt let rec}:
\begin{center}
@"let" "rec" pattern_1 "=" expr_1 "and" \ldots "and" pattern_n "=" expr_n
       "in" expr@
\end{center}
The only difference with the {\tt let} construct described above is
that the bindings of names to values performed by the
pattern-matching are considered already performed when the expressions
@expr_1@ to @expr_n@ are evaluated. That is, the expressions @expr_1@
to @expr_n@ can reference identifiers that are bound by one of the
patterns @pattern_1, \ldots, pattern_n@, and expect them to have the
same value as in @expr@, the body of the {\tt let rec} construct.

The recursive definition is guaranteed to behave as described above if
the expressions @expr_1@ to @expr_n@ are function definitions
(@"fun" \ldots@ or @"function" \ldots@), and the patterns @pattern_1
\ldots pattern_n@ are just value names, as in:
\begin{center}
@"let" "rec" name_1 "=" "fun" \ldots
"and" \ldots
"and" name_n "=" "fun" \ldots
"in" expr@
\end{center}
This defines @name_1 \ldots name_n@ as mutually recursive functions
local to @expr@. 

The behavior of other forms of {\tt let rec} definitions is
implementation-dependent. The current implementation also supports
a certain class of recursive definitions of non-functional values,
such as
\begin{center}
@"let" "rec" name_1 "=" "1" "::" name_2
"and" name_2 "=" "2" "::" name_1
"in" expr@
\end{center}
which binds @name_1@ to the cyclic list "1::2::1::2::"\ldots, and
@name_2@ to the cyclic list "2::1::2::1::"\ldots
Informally, the class of accepted definitions consists of those
definitions where the defined names occur only inside function
bodies or as argument to a data constructor.

\subsection{Control structures}

\subsubsection*{Sequence}

The expression @expr_1 ";" expr_2@ evaluates @expr_1@ first, then
@expr_2@, and returns the value of @expr_2@.

\subsubsection*{Conditional}
\ikwd{if\@\verb`if`}

The expression @"if" expr_1 "then" expr_2 "else" expr_3@ evaluates to
the value of @expr_2@ if @expr_1@ evaluates to the boolean @"true"@,
and to the value of @expr_3@ if @expr_1@ evaluates to the boolean
@"false"@.

The @"else" expr_3@ part can be omitted, in which case it defaults to
@"else" "()"@.

\subsubsection*{Case expression}\ikwd{match\@\verb`match`}

The expression
\begin{latexonly}
$$\begin{array}{rlll}
\token{match} & {\sl expr} \\
\token{with} & {\sl pattern}_1 & \token{->} & {\sl expr}_1 \\
\token{|}     & \ldots \\
\token{|}     & {\sl pattern}_n & \token{->} & {\sl expr}_n
\end{array}$$
\end{latexonly}
\begin{rawhtml}
<pre>
match <i>expr</i> with
      <i>pattern</i>1 -&gt; <i>expr</i>1
    | ...
    | <i>pattern</i>N -&gt; <i>expr</i>N
</pre>
\end{rawhtml}
matches the value of @expr@ against the patterns @pattern_1@ to
@pattern_n@. If the matching against @pattern_i@ succeeds, the
associated expression @expr_i@ is evaluated, and its value becomes the
value of the whole @'match'@ expression. The evaluation of
@expr_i@ takes place in an environment enriched by the bindings
performed during matching. If several patterns match the value of
@expr@, the one that occurs first in the @'match'@ expression is
selected. If none of the patterns match the value of @expr@, the
exception @'Match_failure'@ is raised.
%
\index{Match_failure (exception)\@\verb`Match_failure` (exception)}

\subsubsection*{Boolean operators}

The expression @expr_1 '&' expr_2@ evaluates to @'true'@ if both
@expr_1@ and @expr_2@ evaluate to @'true'@; otherwise, it evaluates to
@'false'@. The first component, @expr_1@, is evaluated first. The
second component, @expr_2@, is not evaluated if the first component
evaluates to @'false'@. Hence, the expression @expr_1 '&' expr_2@ behaves 
exactly as
\begin{center}
@'if' expr_1 'then' expr_2 'else' 'false'@.
\end{center}

\ikwd{or\@\verb`or`}
The expression @expr_1 'or' expr_2@ evaluates to @'true'@ if one of
@expr_1@ and @expr_2@ evaluates to @'true'@; otherwise, it evaluates to
@'false'@. The first component, @expr_1@, is evaluated first. The
second component, @expr_2@, is not evaluated if the first component
evaluates to @'true'@. Hence, the expression @expr_1 'or' expr_2@ behaves 
exactly as
\begin{center}
@'if' expr_1 'then' 'true' 'else' expr_2@.
\end{center}

\subsubsection*{Loops}

\ikwd{while\@\verb`while`}
The expression @'while' expr_1 'do' expr_2 'done'@ repeatedly
evaluates @expr_2@ while @expr_1@ evaluates to @'true'@. The loop
condition @expr_1@ is evaluated and tested at the beginning of each
iteration. The whole @'while' \ldots 'done'@ expression evaluates to
the unit value @'()'@.

\ikwd{for\@\verb`for`}
The expression @'for' name '=' expr_1 'to' expr_2 'do' expr_3 'done'@
first evaluates the expressions @expr_1@ and @expr_2@ (the boundaries)
into integer values \var{n} and \var{p}. Then, the loop body @expr_3@ is
repeatedly evaluated in an environment where @name@ is successively
bound to the values
\begin{latexonly}
   $n$, $n+1$, \ldots, $p-1$, $p$.
   The loop body is never evaluated if $n > p$.
\end{latexonly}
\begin{rawhtml}
   <i>n</i>, <i>n</i>+1, \ldots, <i>p</i>-1, <i>p</i>.
   The loop body is never evaluated if <i>n</i> &gt; <i>p</i>.
\end{rawhtml}

The expression @'for' name '=' expr_1 'downto' expr_2 'do' expr_3 'done'@
evaluates similarly, except that @name@ is successively bound to the values
\begin{latexonly}
   $n$, $n-1$, \ldots, $p+1$, $p$.
   The loop body is never evaluated if $n < p$.
\end{latexonly}
\begin{rawhtml}
   <i>n</i>, <i>n</i>-1, \ldots, <i>p</i>+1, <i>p</i>.
   The loop body is never evaluated if <i>n</i> &lt; <i>p</i>.
\end{rawhtml}

In both cases, the whole @'for'@ expression evaluates to the unit
value @'()'@.

\subsubsection*{Exception handling}
\ikwd{try\@\verb`try`}

The expression
\begin{latexonly}
$$\begin{array}{rlll}
\token{try~} & {\sl expr} \\
\token{with} & {\sl pattern}_1 & \token{->} & {\sl expr}_1 \\
\token{|}   & \ldots \\
\token{|}   & {\sl pattern}_n & \token{->} & {\sl expr}_n
\end{array}$$
\end{latexonly}
\begin{rawhtml}
<pre>
try  <i>expr</i>
with <i>pattern</i>1 -&gt; <i>expr</i>1
    | ...
    | <i>pattern</i>N -&gt; <i>expr</i>N
</pre>
\end{rawhtml}
evaluates the expression @expr@ and returns its value if the
evaluation of @expr@ does not raise any exception. If the evaluation
of @expr@ raises an exception, the exception value is matched against
the patterns @pattern_1@ to @pattern_n@. If the matching against
@pattern_i@ succeeds, the associated expression @expr_i@ is evaluated,
and its value becomes the value of the whole @'try'@ expression. The
evaluation of @expr_i@ takes place in an environment enriched by the
bindings performed during matching. If several patterns match the value of
@expr@, the one that occurs first in the @'try'@ expression is
selected. If none of the patterns matches the value of @expr@, the
exception value is raised again, thereby transparently ``passing
through'' the @'try'@ construct.

\subsection{Operations on data structures}

\subsubsection*{Products}

The expression @expr_1 ',' \ldots ',' expr_n@ evaluates to the
\var{n}-tuple of the values of expressions @expr_1@ to @expr_n@. The
evaluation order for the subexpressions is not specified.

\subsubsection*{Variants}

The expression @ncconstr expr@ evaluates to the variant value whose
constructor is @ncconstr@, and whose argument is the value of @expr@.

For lists, some syntactic sugar is provided. The expression
@expr_1 '::' expr_2@ stands for the constructor @'(' '::' ')' @
applied to the argument @'(' expr_1 ',' expr_2 ')'@, and therefore
evaluates to the list whose head is the value of @expr_1@ and whose tail
is the value of @expr_2@. The expression @'[' expr_1 ';' \ldots ';'
expr_n ']'@ is equivalent to @expr_1 '::' \ldots '::' expr_n '::'
'[]'@, and therefore evaluates to the list whose elements are the
values of @expr_1@ to @expr_n@.

\subsubsection*{Records}

The expression @'{' label_1 '=' expr_1 ';' \ldots ';' label_n '='
expr_n '}'@ evaluates to the record value
@'{' label_1 '=' v_1 ';' \ldots ';' label_n '=' v_n '}'@,
where @v_i@ is the value of @expr_i@ for \fromoneto{i}{n}.
The labels @label_1@ to @label_n@ must all belong to the same record
types; all labels belonging to this record type must appear exactly
once in the record expression, though they can appear in any
order. The order in which @expr_1@ to @expr_n@ are evaluated is not
specified.

The expression @expr_1 '.' label@ evaluates @expr_1@ to a record
value, and returns the value associated to @label@ in this record
value.

The expression @expr_1 '.' label '<-' expr_2@ evaluates @expr_1@ to a record
value, which is then modified in-place by replacing the value
associated to @label@ in this record by the value of
@expr_2@. This operation is permitted only if @label@ has been
declared @'mutable'@ in the definition of the record type. The whole
expression @expr_1 '.' label '<-' expr_2@ evaluates to the unit value
@'()'@.

\subsubsection*{Arrays}

The expression @'[|' expr_1 ';' \ldots ';' expr_n '|]'@ evaluates to
a \var{n}-element array, whose elements are initialized with the values of
@expr_1@ to @expr_n@ respectively. The order in which these
expressions are evaluated is unspecified.

The expression @expr_1 '.(' expr_2 ')'@ returns the value of element
number @expr_2@ in the array denoted by @expr_1@. The first element
has number 0; the last element has number $n-1$, where \var{n} is the
size of the array. The exception "Invalid_argument" is raised if the
access is out of bounds.

The expression @expr_1 '.(' expr_2 ')' '<-' expr_3@ modifies in-place
the array denoted by @expr_1@, replacing element number @expr_2@ by
the value of @expr_3@. The exception "Invalid_argument" is raised if
the access is out of bounds. The value of the whole expression is @'()'@.

\subsubsection*{Strings}

The expression @expr_1 '.[' expr_2 ']'@ returns the value of character
number @expr_2@ in the string denoted by @expr_1@. The first character
has number 0; the last character has number $n-1$, where \var{n} is the
length of the string. The exception "Invalid_argument" is raised if the
access is out of bounds.

The expression @expr_1 '.[' expr_2 ']' '<-' expr_3@ modifies in-place
the string denoted by @expr_1@, replacing character number @expr_2@ by
the value of @expr_3@. The exception "Invalid_argument" is raised if
the access is out of bounds. The value of the whole expression is @'()'@.

\subsection{Operators}

Symbols from the class @'infix-symbols'@, as well as the keywords
"*", "=", "or" and "&", can appear in infix position (between two
expressions). Symbols from the class @'prefix-symbols'@
can appear in prefix position (in front of an expression).

Infix and prefix symbols do not have a fixed meaning: they are simply
interpreted as applications of functions bound to the names
corresponding to the symbols.  The expression @prefix-symbol expr@ is
interpreted as the application @'(' prefix-symbol ')'
expr@. Similarly, the expression @expr_1 infix-symbol expr_2@ is
interpreted as the application @'(' infix-symbol ')' expr_1 expr_2@.

The table below lists the symbols defined in the initial environment
and their initial meaning. (See the description of the standard
library module "Pervasive" in chapter~\ref{c:stdlib} for more
details). Their meaning may be changed at any time using
@"let" "(" infix-op ")" name_1 name_2 "=" \ldots@

\begin{tableau}{|l|p{12cm}|}{Operator}{Initial meaning}
\entree{"+"}{Integer addition.}
\entree{"-" (infix)}{Integer subtraction.}
\entree{"-" (prefix)}{Integer negation.}
\entree{"*"}{Integer multiplication.}
\entree{"/"}{Integer division.
        Raise "Division_by_zero" if second argument is zero. The result is
        unspecified if either argument is negative.}
\entree{"mod"}{Integer modulus. Raise
        "Division_by_zero" if second argument is zero. The result is
        unspecified if either argument is negative.}
\entree{"land"}{Bitwise logical ``and'' on integers.}
\entree{"lor"}{Bitwise logical ``or on integers.}
\entree{"lxor"}{Bitwise logical ``exclusive or'' on integers.}
\entree{"lsl"}{Bitwise logical shift left on integers.}
\entree{"lsr"}{Bitwise logical shift right on integers.}
\entree{"asr"}{Bitwise arithmetic shift right on integers.}
\entree{"+."}{Floating-point addition.}
\entree{"-." (infix)}{Floating-point subtraction.}
\entree{"-." (prefix)}{Floating-point negation.}
\entree{"*."}{Floating-point multiplication.}
\entree{"/."}{Floating-point division.}
\entree{"**"}{Floating-point exponentiation.}
\entree{{\tt\char64} }{List concatenation.}
\entree{"^" }{String concatenation.}
\entree{"!" }{Dereferencing (return the current
        contents of a reference).}
\entree{":="}{Reference assignment (update the
        reference given as first argument with the value of the second
        argument).}
\entree{"=" }{Structural equality test.}
\entree{"<>" }{Structural inequality test.}
\entree{"==" }{Physical equality test.}
\entree{"!=" }{Physical inequality test.}
\entree{"<" }{Test ``less than''.}
\entree{"<=" }{Test ``less than or equal''.}
\entree{">" }{Test ``greater than''.}
\entree{">=" }{Test ``greater than or equal''}
\end{tableau}

\subsection{Objects}

\subsubsection*{Object creation} \label {s:objects}

\ikwd{new\@\verb`new`}
The expression @'new' class-path@ denotes a function that takes some
initialization arguments and returns a new object of class
@class-path@.

\subsubsection*{Message sending}

The expression @expr '#' method-name@ invokes the method
@method-name@ of the object denoted by @expr@.

\subsubsection*{Coercion}

The type of an object can be coerced (weakened) to a subtype.
%
The expression @'(' expr ':>' typexpr ')'@ coerces the expression @expr@
to type @typexpr@.
%
The expression @'(' expr ':' typexpr_1 ':>' typexpr_2 ')'@ coerces the
expression @expr@ from type @typexpr_1@ to type @typexpr_2@. It is
more general than the previous one.

\subsubsection*{Object duplication}

An object can be duplicated using the library function "Oo.copy"
(see section~\ref{s:Oo}).

%% \newpage
