\section{Classes}

\subsection{Class definitions}

\ikwd{and\@\verb`and`}
\ikwd{as\@\verb`as`}
\ikwd{class\@\verb`class`}
\ikwd{closed\@\verb`closed`}
\ikwd{constraint\@\verb`constraint`}
\ikwd{end\@\verb`end`}
\ikwd{inherit\@\verb`inherit`}
\ikwd{method\@\verb`method`}
\ikwd{mutable\@\verb`mutable`}
\ikwd{private\@\verb`private`}
\ikwd{then\@\verb`then`}
\ikwd{val\@\verb`val`}
\ikwd{virtual\@\verb`virtual`}

\begin{syntax}
class-definition:
    class-header '=' [constraints] { class-fields }
;
class-header:
    class-tags parameterized-class-name class-params class-binders
;
class-tags:
    ['virtual'] ['closed']
;
parameterized-class-name:
    class-name
  | "'" ident class-name
  | '(' "'" ident { ',' "'" ident } ')' class-name
;
class-params:
    {{ pattern }}
;
class-binders:
    ['as' value-name] [':' "'" ident]
;
constraints:
    { 'constraint' "'" ident '=' typexpr }
;
class-fields:
    'inherit' ancestor
  | 'val' value
  | 'virtual' method-type
  | 'method' method
;
ancestor:
    [ '(' typexpr { ',' typexpr } ')' ] class-path {{ expr }} ['as' value-name]
;
value:
    ['private'] ['mutable'] inst-var-name ['=' expr]
;
method:
    method-name { pattern } '=' expr
;
method-type:
    method-name ':' typexpr
;
\end{syntax}

\subsubsection*{Class definitions}

A class definition @'class' class-definition { 'and' class-definition }@
is recursive. Each @class-definition@ defines a @class-name@ that can be
used in the whole expression except for inheritance. 

\subsubsection*{Type parameters}

A class @class-name@ automatically defines two abbreviations :
@class-name@ and @'#' class-name@. The first one is the type of
objects of this class, while the second is more general as it unifies
with the type of any object belonging to a subclass (see
section~\ref{s:sharp-types}).

The class type parameters corresponds to the ones of these two
abbreviations. They must be bound to actual types in the class
definition using type constraints. The abbreviations are obtained by
pruning the method types at all occurrences of a type parameter.  So
that the abbreviations are well-formed, no type variable must remain in
the pruned types.

\subsubsection*{Class parameters}

The parameters @class-params@ are the ones of the object creation
function @'new' class-path@, as well as the ones of the inheritance
construct.

\subsubsection*{Self and self type binders}

\ikwd{as\@\verb`as`}
The binders @class-binders@, i.e.  @'as' value-name@ and @':' "'" ident@,
allow
to bind self (the current object) and its type, respectively. The variable
@value-name@ can then be used as any variable in methods body.

\subsubsection*{Constraints on type parameters}

\ikwd{constraint\@\verb`constraint`}
The construct @{ 'constraint' "'" ident '=' typexpr }@ allows to
specify type parameters.  The value of the type parameter @ident_i@
will be an instance of @typexpr_i@ (more precisely, @ident_i@ and
@typexpr_i@ are unified).

\subsubsection*{Inheritance}

\ikwd{inherit\@\verb`inherit`}
The inheritance construct
@'inherit' [ '(' typexpr { ',' typexpr } ')' ] class-path {{ expr }}@
allows to reuse methods from other classes. It adds the instance
variables and methods from class @class-path@ into the current class,
possibly overriding previously defined ones of the same name.  %
Parent instance variables are initialized with parent class parameters
bound to the arguments @{{expr}}@. Parent type parameters are unified
with type arguments @typexpr_1, \ldots, typexpr_n@.

\ikwd{inherit\@\verb`as`}
An ancestor can be bound by prepending the construct @'as' value-name@
to the inheritance construct above.  @value-name@ is not a true
variable and can only be used to select a method, i.e. in an expression
@value-name '#' method-name@.  This gives access to the
method @method-name@ as it was defined in the parent class even if it is
redefined in the current class.

\subsubsection*{Instance variable definition}

\ikwd{val\@\verb`val`}
\ikwd{mutable\@\verb`mutable`}
\ikwd{private\@\verb`private`}
Instance variables can be defined or their status can be changed using the
construct @'val' value@.

The definition @'val' ['private'] ['mutable'] inst-var-name '=' expr@ adds
an instance variable 
@inst-var-name@ whose initial value is the value of expression @expr@.
If the variable was previously defined, its previous initial value is
overridden.
%
By default, this variable is visible in subclasses of current class.
The flag @'private'@ makes this variable only
visible in the current class.
%
The flag @'mutable'@ allows physical modification of this variable by
methods.

The construct @'val' ['private'] ['mutable'] inst-var-name@ enables to
change the variable status (makes it private and/or mutable), while
keeping the same initial value.

\subsubsection*{Method definition}

\ikwd{method\@\verb`method`}

Method definition is written @'method' method@.  The definition of a
method overrides any previous definition of this method.

Method bodies do not have access to class parameters, but to instance
variables.  Some special
expressions are available in method bodies for manipulating instance
variables and duplicating self:
\begin{syntax}
expr:
    \ldots
  | inst-var-name
  | inst-var-name '<-' expr
  | '{<' [ inst-var-name '=' expr { ';' inst-var-name '=' expr } ] '>}'
;
\end{syntax}

The expression @inst-var-name@ evaluates to the value of the
corresponding instance variable in the current object, while the
expression @inst-var-name '<-' expr@ modifies in-place the current
object by replacing the value associated to @inst-var-name@ by the
value of @expr@. Of course, this instance variable must be mutable.

The expression
@'{<' [ inst-var-name '=' expr { ';' inst-var-name '=' expr } ] '>}'@
evaluates to a copy of the current object in which the values of
instance variables @inst-var-name_1, \ldots, inst-var-name_n@ have
been replaced by the values of the corresponding expressions @expr_1,
\ldots, expr_n@.

\subsubsection*{Virtual class}

\ikwd{virtual\@\verb`virtual`}
Methods can be declared, without being defined, with the construct
@'virtual' method-type@.  Methods that are declared in this way or
applied to self but not actually defined are said to be virtual.
%
A class must be flagged virtual if one of its methods is virtual. 
Objects cannot be created from a virtual class.

\subsubsection*{Closed class}

\ikwd{closed\@\verb`closed`}
A class can be flagged as @'closed'@.  A closed class is a class
to which subclasses cannot add methods.

\subsection{Class types}

\ikwd{and\@\verb`and`}
\ikwd{as\@\verb`as`}
\ikwd{class\@\verb`class`}
\ikwd{closed\@\verb`closed`}
\ikwd{constraint\@\verb`constraint`}
\ikwd{end\@\verb`end`}
\ikwd{inherit\@\verb`inherit`}
\ikwd{method\@\verb`method`}
\ikwd{mutable\@\verb`mutable`}
\ikwd{private\@\verb`private`}
\ikwd{then\@\verb`then`}
\ikwd{val\@\verb`val`}
\ikwd{virtual\@\verb`virtual`}

Class types are specifications for class definitions. The syntax of
class types is closely modeled on class definitions.

\begin{syntax}
class-type:
    class-type-header '=' [constraints] { class-type-fields }
;
class-type-header:
    class-tags parameterized-class-name class-type-params
    [':' "'" ident]
;
class-type-params:
    {{ '(' typexpr ')' }}
;
class-type-fields:
    'inherit' ancestor-type
  | 'val' value-type
  | 'virtual' method-type
  | 'method' method-type
;
ancestor-type:
    [ '(' typexpr { "," typexpr } ')' ] class-path
;
value-type:
    ['private'] ['mutable'] inst-var-name [':' typexpr]
;
method-type:
    method-name ':' typexpr
;
\end{syntax}
