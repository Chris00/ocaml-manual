\section{Classes}
\pdfsection{Classes}

Classes are defined using a small language, similar to the module
language.

\subsection{Class types}

Class types are the class-level equivalent of type expressions: they
specify the general shape and type properties of classes.

\ikwd{object\@\texttt{object}}
\ikwd{end\@\texttt{end}}
\ikwd{inherit\@\texttt{inherit}}
\ikwd{val\@\texttt{val}}
\ikwd{mutable\@\texttt{mutable}}
\ikwd{method\@\texttt{method}}
\ikwd{private\@\texttt{private}}
\ikwd{virtual\@\texttt{virtual}}
\ikwd{constraint\@\texttt{constraint}}

\begin{syntax}
class-type:
   |  class-body-type
   |  typexpr '->' class-type
;
class-body-type:
      'object' ['(' typexpr ')'] {class-field-spec} 'end'
   |  class-path
   |  '[' typexpr {',' typexpr} ']' class-path
;
class-field-spec:
      'inherit' class-type
   |  'val' ['mutable'] inst-var-name ':' typexpr
   |  'method' ['private'] method-name ':' typexpr
   |  'method' ['private'] 'virtual' method-name ':' typexpr
   |  'constraint' typexpr '=' typexpr
;
\end{syntax}

\subsubsection*{Simple class expressions}

The expression @class-path@ is equivalent to the class type bound to
the name @class-path@. Similarly, the expression
@'[' typexpr_1 ',' \ldots typexpr_n ']' class-path@ is equivalent to
the parametric class type bound to the name @class-path@, in which
type parameters have been instanciated to respectively @typexpr_1@,
\ldots @typexpr_n@.

\subsubsection*{Class function type}

The class type expression @typexpr '->' class-type@ is the type of
class functions (functions from values to classes) that take as
argument a value of type @typexpr@ and return as result a class of
type @class-type@.

\subsubsection*{Class body type}

The class type expression
@'object' ['(' typexpr ')'] {class-field-spec} 'end'@
is the type of a class body. It specifies its instance variables and
methods. In this type, @typexpr@ is match agains self type, therefore
provinding a binding for self type.

A class body will match a class body type if it provides definitions
for all the components specified in the class type, and these
definitions meet the type requirements given in the class type.
Furthermore, all methods either virtual or public present in the class
body must also be present in the class type (on the other hand, some
instance variables and concrete private methods may be omitted).  A
virtual method will match a concrete method, thus allowing to forget
its implementation. An immutable instance variable will match a
mutable instance variable.

\subsubsection*{Inheritance}

\ikwd{inherit\@\texttt{inherit}}

The inheritance construct @'inherit' class-type@ allows to include
methods and instance variables from other classes types.
The instance variable and method types from this class type are added
into the current class type.

\subsubsection*{Instance variable specification}

\ikwd{val\@\texttt{val}}
\ikwd{mutable\@\texttt{mutable}}

A specification of an instance variable is written
@'val' ['mutable'] inst-var-name ':' typexpr@, where @inst-var-name@
is the name of the instance variable and @typexpr@ its expected type.
%
The flag @'mutable'@ indicates whether this instance variable can be
physically modified.

An instance variable specification will hide any previous
specification of an instance variable of the same name.

\subsubsection*{Method specification}

\ikwd{method\@\texttt{method}}
\ikwd{private\@\texttt{private}}

A specification of an method is written
@'method' ['private'] method-name ':' typexpr@, where @method-name@ is
the name of the method and @typexpr@ its expected type. The flag
@'private'@ indicates whether the method can be accessed from outside
the class.

Several specification for the same method must have compatible types.

\subsubsection*{Virtual method specification}

\ikwd{virtual\@\texttt{virtual}}
\ikwd{method\@\texttt{method}}
\ikwd{private\@\texttt{private}}

Virtual method specification is written @'method' ['private']
'virtual' method-name ':' typexpr@, where @method-name@ is the name of
the method and @typexpr@ its expected type.

\subsubsection*{Constraints on type parameters}

\ikwd{constraint\@\texttt{constraint}}

The construct @'constraint' typexpr_1 '=' typexpr_2@ forces the two
type expressions to be equals. This is typically used to specify type
parameters: they can be that way be bound to a specified type
expression.

\subsection{Class expressions}

Class expressions are the class-level equivalent of value expressions:
they evaluate to classes, thus providing implementations for the
specifications expressed in class types.

\ikwd{object\@\texttt{object}}
\ikwd{end\@\texttt{end}}
\ikwd{fun\@\texttt{fun}}
\ikwd{let\@\texttt{let}}
\ikwd{rec\@\texttt{rec}}
\ikwd{in\@\texttt{in}}
\ikwd{and\@\texttt{and}}
\ikwd{inherit\@\texttt{inherit}}
\ikwd{as\@\texttt{as}}
\ikwd{val\@\texttt{val}}
\ikwd{mutable\@\texttt{mutable}}
\ikwd{method\@\texttt{method}}
\ikwd{private\@\texttt{private}}
\ikwd{virtual\@\texttt{virtual}}
\ikwd{constraint\@\texttt{constraint}}
\ikwd{initializer\@\texttt{initializer}}

\begin{syntax}
class-expr:
      class-path
   |  '[' typexpr {',' typexpr} ']' class-path
   |  '(' class-expr ')'
   |  '(' class-expr ':' class-type ')'
   |  class-expr expr
   |  'fun' {{pattern}} '->' class-expr
   |  'let' ['rec'] let-binding {'and' let-binding} 'in' class-expr
   |  'object' ['(' pattern [':' typexpr] ')'] { class-field } 'end'
;
class-field:
      'inherit' class-expr ['as' value-name]
   |  'val' ['mutable'] inst-var-name '=' expr
   |  'method' ['private'] method-name {pattern} '=' expr
   |  'method' ['private'] 'virtual' method-name ':' typexpr
   |  'constraint' typexpr '=' typexpr
   |  'initializer' expr
;
\end{syntax}

\subsubsection*{Simple class expressions}

The expression @class-path@ evaluates to the class bound to the name
@class-path@. Similarly, the expression
@'[' typexpr_1 ',' \ldots typexpr_n ']' class-path@
evaluates to the parametric class bound to the name @class-path@,
in which type parameters have been instanciated to respectively
@typexpr_1@, \ldots @typexpr_n@.

The expression @'(' class-expr ')'@ evaluates to the same module as
@class-expr@.

The expression @'(' class-expr ':' class-type ')'@ checks that
@class-type@ match the type of @class-expr@ (that is, that the
implementation @class-expr@ meets the type specification
@class-type@). The whole expression evaluates to the same class as
@class-expr@, except that all components not specified in
@class-type@ are hidden and can no longer be accessed.

\subsubsection*{Class application}

Class application is denoted by juxtaposition of expressions. The
expression @class-expr expr@ evaluates the expressions @class-expr@
and @expr@. The expression @class-expr@ must evaluate to a functional
class value, which is then applied to the value of @expr@.

\subsubsection*{Class function}

The expression @'fun' pattern '->' class-expr@ evaluates to a
function from values to classes.
When this function is applied to a value \var{v}, this value is
matched against the pattern @pattern@ and the result is the result of
the evaluation of @class-expr@ in the extended environment.

The expression
\begin{center}
@"fun" pattern_1 \ldots pattern_n "->" class-expr@
\end{center}
is a short form for
\begin{center}
@"fun" pattern_1 "->" \ldots "fun" pattern_n "->" expr@
\end{center}

\subsubsection*{Local definitions}

The {\tt let} and {\tt let rec} constructs bind value names locally,
as for the core language expressions.

\subsubsection*{Class body}

The expression
@'object' '(' pattern [':' typexpr] ')' { class-field } 'end'@ denotes
a class body. This is the prototype for an object : it lists the
instance variables and methods of an objet of this class.

A class body is a class value: it is not evaluated at once. Rather,
its components are evaluated each time an object is created.

In a class body, the pattern @'(' pattern [':' typexpr] ')'@ is
matched against self, therefore provinding a binding for self and self
type.  Self can only be used in method and initializers.

Self type cannot be a closed object type, so that the class remains
extensible.

\subsubsection*{Inheritance}

\ikwd{inherit\@\texttt{inherit}}

The inheritance construct @'inherit' class-expr@ allows to reuse
methods and instance variables from other classes. The class
expression @class-expr@ must evaluate to a class body.  The instance
variables, methods and initializers from this class body are added
into the current class.  The addition of a method will override any
previously defined methods of the same name.

\ikwd{as\@\texttt{as}}
An ancestor can be bound by prepending the construct @'as' value-name@
to the inheritance construct above.  @value-name@ is not a true
variable and can only be used to select a method, i.e. in an expression
@value-name '#' method-name@.  This gives access to the
method @method-name@ as it was defined in the parent class even if it is
redefined in the current class. 
The scope of an ancestor binding is limited to the current class. 
The ancestor method may be called from a subclass but only indirectly. 

\subsubsection*{Instance variable definition}

\ikwd{val\@\texttt{val}}
\ikwd{mutable\@\texttt{mutable}}

The definition @'val' ['mutable'] inst-var-name '=' expr@ adds an
instance variable @inst-var-name@ whose initial value is the value of
expression @expr@.  Several variables of the same name can be defined
in the same class.
%
The flag @'mutable'@ allows physical modification of this variable by
methods.

An instance variables can only be used in the following methods and
initializers of the class.

\subsubsection*{Method definition}

\ikwd{method\@\texttt{method}}
\ikwd{private\@\texttt{private}}

Method definition is written @'method' method-name '=' expr@.  The
definition of a method overrides any previous definition of this
method.  The method will be public (that is, not private) if any of
the definition states so.

A private method, @'method' 'private' method-name '=' expr@, is a
method that can only be invoked on self (from other methods of the
current class as well as of subclasses of the current class).  This
invocation is performed using the expression
@value-name '#' method-name@, where @value-name@ is directly bound to
self at the beginning of the class definition.  Private methods do
not appear in object types.

Some special expressions are available in method bodies for
manipulating instance variables and duplicating self:
\begin{syntax}
expr:
    \ldots
  | inst-var-name '<-' expr
  | '{<' [ inst-var-name '=' expr { ';' inst-var-name '=' expr } ] '>}'
;
\end{syntax}

The expression @inst-var-name '<-' expr@ modifies in-place the current
object by replacing the value associated to @inst-var-name@ by the
value of @expr@. Of course, this instance variable must have been
declared mutable.

The expression
@'{<' [ inst-var-name '=' expr { ';' inst-var-name '=' expr } ] '>}'@
evaluates to a copy of the current object in which the values of
instance variables @inst-var-name_1, \ldots, inst-var-name_n@ have
been replaced by the values of the corresponding expressions @expr_1,
\ldots, expr_n@.

\subsubsection*{Virtual method definition}

\ikwd{virtual\@\texttt{virtual}}
\ikwd{method\@\texttt{method}}
\ikwd{private\@\texttt{private}}

Method specification is written @'method' ['private'] 'virtual'
method-name ':' typexpr@.  It specifies whether the method is public
or private, and gives its type.

\subsubsection*{Constraints on type parameters}

\ikwd{constraint\@\texttt{constraint}}

The construct @'constraint' typexpr_1 '=' typexpr_2@ forces the two
type expressions to be equals. This is typically used to specify type
parameters: they can be that way be bound to a specified type
expression.

\subsubsection*{Initializers}

\ikwd{initializer\@\texttt{initializer}}

A class initializer @'initializer' expr@ specifies an expression that
will be evaluated when an object will be created from the class, once
all the instance variables have been initialized.

\subsection{Class definitions}
\label{s:classdef}

\ikwd{class\@\texttt{class}}
\ikwd{and\@\texttt{and}}
\ikwd{virtual\@\texttt{virtual}}

\begin{syntax}
class-definition:
          'class' class-binding { 'and' class-binding }
;
class-binding:
          ['virtual'] ['[' type-parameters ']'] class-name
          { pattern } [':' class-type] '=' class-expr
;
type-parameters:
          "'" ident { "," "'" ident }
;
\end{syntax}

A class definition @'class' class-binding { 'and' class-binding }@ is
recursive. Each @class-binding@ defines a @class-name@ that can be
used in the whole expression except for inheritance. It can also be
used for inheritance, but only in the definitions that follow its own.

A class binding binds the class name @class-name@ to the value of
expression @class-expr@. It also binds the class type @class-name@ to
the type of the class, and defines two type abbreviations :
@class-name@ and @'#' class-name@. The first one is the type of
objects of this class, while the second is more general as it unifies
with the type of any object belonging to a subclass (see
section~\ref{s:sharp-types}).

\subsubsection*{Virtual class}

\ikwd{virtual\@\texttt{virtual}}
A class must be flagged virtual if one of its methods is virtual (that
is, appears in the class type, but is not actually defined).
Objects cannot be created from a virtual class.

\subsubsection*{Type parameters}

The class type parameters correspond to the ones of the class type and
of the two type abbreviations defined by the class binding.  They must
be bound to actual types in the class definition using type
constraints.  So that the abbreviations are well-formed, type
variables of the inferred type of the class must either be type
parameters or be bound in the constraint clause.

\subsection{Class specification}
\label{s:class-spec}

\ikwd{class\@\texttt{class}}
\ikwd{and\@\texttt{and}}
\ikwd{virtual\@\texttt{virtual}}

\begin{syntax}
class-specification:
           'class' class-spec { 'and' class-spec }
;
class-spec:
           ['virtual'] ['[' type-parameters ']'] class-name ':'
           class-type
;
\end{syntax}

This is the counterpart in signatures of class definitions.
A class specification matches a class definition if they have the same
type parameters and their types match.

\subsection{Class type definitions}
\label{s:classtype}

\ikwd{class\@\texttt{class}}
\ikwd{type\@\texttt{type}}
\ikwd{and\@\texttt{and}}
\ikwd{virtual\@\texttt{virtual}}

\begin{syntax}
classtype-definition:
           'class' 'type' classtype-def
                  { 'and' classtype-def }
;
classtype-def:
    ['virtual'] ['[' type-parameters ']'] class-name '=' class-body-type
;
\end{syntax}

A class type definition @'class' class-name '=' class-body-type@
defines an abbreviation @class-name@ for the class body type
@class-body-type@.  As for class definitions, two type abbreviations
@class-name@ and @'#' class-name@ are also defined. The definition can
be parameterized by some type parameters. If any method in the class
type body is virtual, the definition must be flagged @virtual@.

Two class type definitions match if they have the same type parameters
and the types they expand to match.
