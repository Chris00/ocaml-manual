\chapter{An introduction to the module system}
\label{c:intro-modules}

This chapter is a tutorial introduction to the module system of Caml
Special Light.

\section{Structures}

A primary motivation for modules is to package together related
definitions (such as the definitions of a data type and associated
operations over that type) and enforce a consistent naming scheme for
these definitions. This avoids running out of names or accidentally
confusing names. Such a package is called a {\em structure} and
is introduced by the "struct"\ldots"end" construct, which contains an
arbitrary sequence of definitions. The structure is usually given a
name with the "module" binding. Here is for instance a structure
packaging together a type of priority queues and their operations:
\begin{caml_example}
module PrioQueue =
  struct
    type priority = int
    type 'a queue = Empty | Node of priority * 'a * 'a queue * 'a queue
    let empty = Empty
    let rec insert queue prio elt =
      match queue with
        Empty -> Node(Empty, prio, elt, Empty)
      | Node(p, e, left, right) ->
          if prio <= p
          then Node(prio, elt, add right p e, left)
          else Node(p, e, add right prio elt, left)
    exception Queue_is_empty
    let rec remove_top = function
        Empty -> raise Queue_is_empty
      | Node(prio, elt, left, Empty) -> left
      | Node(prio, elt, Empty, right) -> right
      | Node(prio, elt, (Node(lprio, lelt, _, _) as left),
                        (Node(rprio, relt, _, _) as right)) ->
          if lprio <= rprio
          then Node(lprio, lelt, remove_top left, right)
          else Node(rprio, relt, left, remove_top right)
    let extract = function
        Empty -> raise Queue_is_empty
      | Node(prio, elt, _, _) as queue -> (prio, elt, remove_top queue)
  end;;
\end{caml_example}
Outside of the structure, its components can be referred to using the
``dot notation'', that is, identifiers qualified by a structure name.
For instance, "PrioQueue.insert" in a value context is
the function "insert" defined inside the structure
"PrioQueue". Similarly, "PrioQueue.queue" in a type context is the
type "queue" defined in "PrioQueue". 
\begin{caml_example}
PrioQueue.add 1 "hello" PrioQueue.empty;;
\end{caml_example}

\section{Signatures}

Signatures are interfaces for structures. A signature specifies
which components of a structure are accessible from the outside, and
with which type. It can be used to hide some components of a structure 
(e.g. local function definitions) or export some components with a
restricted type. For instance, the signature below specifies the three
priority queue operations "empty", "insert" and "extract", but not the
auxiliary function "remove_top". Similarly, it makes the "queue" type
abstract (by not providing its actual representation as a concrete type)
\begin{caml_example}
module type PRIOQUEUE =
  sig
    type priority = int         (* still concrete *)
    type 'a queue               (* now abstract *)
    val empty : 'a queue
    val insert : 'a queue -> int -> 'a -> 'a queue
    val extract : 'a queue -> int * 'a * 'a queue
    exception Queue_is_empty
  end;;
\end{caml_example}
Restricting the "PrioQueue" structure by this signature results in
another view of the "PrioQueue" structure where the "remove_top"
function is not accessible and the actual representation of priority
queues is hidden:
\begin{caml_example}
module AbstractPrioQueue = (PrioQueue : PRIOQUEUE);;
AbstractPrioQueue.remove_top;;
AbstractPrioQueue.add 1 "hello" AbstractPrioQueue.empty;;
\end{caml_example}
The restriction can also be performed during the definition of the
structure, as in
\begin{verbatim}
module PrioQueue = (struct ... end : PRIOQUEUE);;
\end{verbatim}
An alternate syntax is provided for the above:
\begin{verbatim}
module PrioQueue : PRIOQUEUE = struct ... end;;
\end{verbatim}

\section{Functors}

Functors are functions from structures to structures. They are used to
express parameterized structures: a structure "A" parameterized by a
structure "B" is simply a functor "F" with a formal parameter "B" (along
with the expected signature for "B") which returns the actual
structure "A" itself. The functor "F" can then be applied to one or
several implementations $"B"_1, \ldots, "B"_n$ of "B", yielding the
corresponding structures $"A"_1, \ldots, "A"_n$.

For instance, here is a structure implementing sets as sorted lists,
parameterized by a structure providing the type of the set elements
and an ordering function over this type (used to keep the sets
sorted):
\begin{caml_example}
type comparison = Less | Equal | Greater;;

module type ORDERED_TYPE =
  sig
    type t
    val cmp: t -> t -> comparison
  end;;

module Set =
  functor (Elt: ORDERED_TYPE) ->
    struct
      type element = Elt.t
      type set = element list
      let empty = []
      let rec add x s =
        match s with
          [] -> [x]
        | hd::tl ->
           match Elt.cmp x hd with
             Equal   -> s         (* x is already in s *)
           | Less    -> x :: s    (* x is smaller than all elements of s *)
           | Greater -> hd :: add x tl
      let rec member x s =
        match s with
          [] -> false
        | hd::tl ->
            match Elt.cmp x hd with
              Equal   -> true     (* x belongs to s *)
            | Less    -> false    (* x is smaller than all elements of s *)
            | Greater -> member x tl
    end;;
\end{caml_example}
By applying the "Set" functor to a structure implementing an ordered
type, we obtain set operations for this type:
\begin{caml_example}
module OrderedString =
  struct
    type t = string
    let cmp x y = if x = y then Equal else if x < y then Less else Greater
  end;;
module StringSet = Set(OrderedString);;
StringSet.mem "bar" (StringSet.add "foo" StringSet.empty);;
\end{caml_example}

\section{Functors and type abstraction}

As in the "PrioQueue" example, it would be good style to hide the
actual implementation of the type "set", so that users of the
structure will not rely on sets being lists, and we can switch later
to another, more efficient representation of sets without breaking
any code. This can be achieved by restricting "Set" by a suitable
functor signature:
\begin{caml_example}
module type SETFUNCTOR =
  functor (Elt: ORDERED_TYPE) ->
    sig
      type element = Elt.t      (* concrete *)
      type set                  (* abstract *)
      val empty : set
      val add : element -> set -> set
      val member : element -> set -> bool
    end;;
module AbstractSet = (Set : SETFUNCTOR);;
module AbstractStringSet = AbstractSet(OrderedString);;
AbstractStringSet.add "gee" AbstractStringSet.empty;;
\end{caml_example}

In an attempt to write the type constraint above more elegantly,
one may wish to name the signature of the structure
returned by the functor, then use that signature in the constraint:
\begin{caml_example}
module type SET =
  sig
    type element
    type set
    val empty : set
    val add : element -> set -> set
    val member : element -> set -> bool
  end;;
module WrongSet = (Set : functor(Elt: ORDERED_TYPE) -> SET);;
module WrongStringSet = WrongSet(OrderedString);;
WrongStringSet.add "gee" WrongStringSet.empty;;
\end{caml_example}
The problem here is that "SET" specifies the type "element"
abstractly, so that the type equality between "element" in the result
of the functor and "t" in its argument is forgotten. Consequently,
"WrongStringSet.element" is not the same type as "string", and the
operations of "WrongStringSet" cannot be applied to strings.
As demonstrated above, it is important that the type "element" in the
signature "SET" be declared equal to "Elt.t"; unfortunately, this is
impossible above since "SET" is defined in a context where "Elt" does
not exist. To overcome this difficulty, Caml provides a "with type"
construct over signatures that allow to enrich a signature with extra
type equalities:
\begin{caml_example}
module AbstractSet = 
  (Set : functor(Elt: ORDERED_TYPE) -> (SET with type element = Elt.t));;
\end{caml_example}

As in the case of simple structures, an alternate syntax is provided
for defining functors and restricting their result:
\begin{verbatim}
module AbstractSet(Elt: ORDERED_TYPE) : (SET with type element = Elt.t) =
  struct ... end;;
\end{verbatim}

Abstracting a type component in a functor result is a powerful
technique that provides a high degree of type safety, as we now
illustrate. Consider an ordering over character strings that is
different from the standard ordering implemented in the
"OrderedString" structure. For instance, we compare strings without
distinguishing upper and lower case.
\begin{caml_example}
module NoCaseString =
  struct
    type t = string
    let normalize s =           (* Convert to lowercase *)
      let r = String.copy s in
      for i = 0 to String.length r - 1 do
        if r.[i] >= 'A' && r.[i] <= 'Z' then
          r.[i] <- Char.chr(Char.code r.[i] + 32)
      done;
      r
    let cmp s1 s2 = OrderedString.cmp (normalize s1) (normalize s2)
  end;;
module NoCaseStringSet = AbstractSet(NoCaseString);;
NoCaseStringSet.add "FOO" AbstractStringSet.empty;;
\end{caml_example}
Notice that the two types "AbstractStringSet.set" and 
"NoCaseStringSet.set" are not compatible, and values of these
two types do not match. This is the correct behavior: even though both
set types contain elements of the same type (strings), both are built
upon different orderings of that type, and different invariants need
to be maintained by the operations (being strictly increasing for the
standard ordering and for the case-insensitive ordering). Applying
operations from "AbstractStringSet" to values of type
"NoCaseStringSet.set" could give incorrect results, or build
lists that violate the invariants of "NoCaseStringSet".

\section{Modules and separate compilation}

