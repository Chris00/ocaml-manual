\chapter{Labels and variants} \label{c:labl-examples}
\pdfchapterfold{-2}{Tutorial: Labels and variants}

{\it (Chapter written by Jacques Garrigue)}

\bigskip

\noindent This chapter gives an overview of the new features in
Objective Caml 3: labels, and polymorphic variants.

\section{Labels}
\pdfsection{Labels}

If you have a look at the standard library, you will see that function
types have annotations you did not see in the functions you defined
yourself.

\begin{caml_example}
List.map;;
String.sub;;
\end{caml_example}

Such annotations of the form "name:" are called {\em labels}. They are
meant to document the code, and allow more checking where needed.
You can add them in interfaces, just like they appear in the above
types, and also write them directly in your programs.

\begin{caml_example}
let f x:x y:y = x - y;;
f x:3 y:2;;
\end{caml_example}

In order to lighten the notations, the expression "name: name", where
"name" is either a pattern variable or an identifier, can be
abbreviated in ":name".

\begin{caml_example}
let f :x :y = x - y;;
let pred x = f :x y:1;;
\end{caml_example}

%% FIXME
Beware that if you use this abbreviated notation with labels named
after keywords ({\em e.g.} ":fun", ":to"), you will not be able to use
the newly defined variable, since its name is masked by the keyword!
In such cases you should avoid the abbreviated notation, and write
"fun:f" for instance.

\paragraph{Warning}
Since the colon ":" is used inside labels, you must be careful to put
spaces around it in type annotations. You must write "(x : int)" and
not "(x:int)". You may omit the space before the colon in type
definitions and interface declarations, like in "val x: int".

\subsection{Classic mode}

In Objective Caml, there are two ways of using labels, either the
default {\em classic} mode, or the {\em commuting label} mode.

You need do nothing special to be in classic mode, and legacy programs
written for previous versions of Objective Caml will work with no
modifications in this mode, except for the problem mentioned in the
above warning.

In the classic mode, labels need not be explicitly written in
function applications, but whenever they are given they are checked
against the labels in the function type.

\def\myerror{3}
\begin{caml_example}
f 3 2;;
f x:3 z:2;;
\end{caml_example}
The above error message gives the the type of the function applied to
its previous arguments (here "x"), and the position of the unexpected
argument.

Similar processing is done for functions defined inside an application.
If you define inline a function with labels, they are checked against the
labels expected by the enclosing function.

\begin{caml_example}
List.fold_left;;
let sum = List.fold_left fun:(fun :acc x -> acc + x) acc:0;;
let sum = List.fold_left fun:(fun x :acc -> acc + x) acc:0;;
\end{caml_example}

\subsection{Modern mode}

You can switch to {\em commuting label} mode giving the "-labels" flag to the
various Objective Caml compilers. You can also switch from classic
mode to commuting label mode, and back, with the "#labels" pragma.

\begin{caml_example}
#labels true;;
\end{caml_example}

The commuting label mode allows a freer syntax, at the constraint that you must
write all labels both in function definition and application, and that
labels must match in all types.

In commuting label mode, formal parameters and arguments are only matched
according to their respective labels. This allows commuting arguments
in applications. One can also partially apply a function on any
argument, creating a new function of the remaining parameters.

\begin{caml_example}
f y:2 x:3;;
List.fold_left [1;2;3] acc:0 fun:(fun :acc x -> acc + x);;
List.fold_left [1;2;3];;
\end{caml_example}

For such out-of-order applications, the type of the function must be
known previous to the application, otherwise an incompatible
out-of-order type will be generated. See
section~\ref{ss:label-inference} for more details.

\begin{caml_example}
let h g = g y:2 x:3;;
h f;;
\end{caml_example}

If in a function several arguments bear the same label (or no label),
they will not commute among themselves, and order matters. But they
can still commute with other arguments.

\begin{caml_example}
let hline x:x1 x:x2 :y = (x1, x2, y);;
hline x:3 y:2 x:5;;
\end{caml_example} 

\subsection{Optional arguments}

An interesting feature of labeled arguments is that they can be made
optional. An optional parameter is prefixed by a question mark "?" in
the function definition, and it the function type.
Default values may be given for such optional parameters.

\begin{caml_example}
let bump ?(:step = 1) x = x + step;;
bump 2;;
bump step:3 2;;
\end{caml_example}

A function taking some optional arguments must also take at least one
non-labeled argument. This is because the criterion for deciding
whether an optional has been omitted is the application on a
non-labeled argument appearing after this optional argument in the
function type.

\begin{caml_example}
let test ?(:x = 0) ?(:y = 0) () ?(:z = 0) () = (x, y, z);;
test ();;
test x:2 () z:3 ();;
\end{caml_example}

Optional arguments behave similarly in classic and commuting label
mode. Omitting the label of an optional argument is not allowed,
and in both cases commutation between differently labeled optional
arguments may occur. However commutation between an optional argument
and other labeled or non-labeled arguments is only allowed in commuting label
mode.

\begin{caml_example}
test y:2 () ();;
\end{caml_example}

Optional arguments are actually implemented as option types. If
you do not give a default value, you have access to their internal
representation, "type 'a option = None | Some of 'a". You can then
provide different behaviors when an argument is present or not.

\begin{caml_example}
let bump ?:step x =
  match step with
  | None -> x * 2
  | Some y -> x + y
;;
\end{caml_example}

It may also be useful to relay a functional argument from a function
call to another. This can be done by prefixing the applied argument
with "?". This question mark disables the wrapping of optional
argument in an option type.

\begin{caml_example}
let test2 ?:x ?:y () = test ?:x ?:y () ();;
test2 ?x:None;;
\end{caml_example}

\subsection{Labels and type inference}
\label{ss:label-inference}

While they provide an increased comfort for writing function
applications, labels and optional arguments have the pitfall that they
cannot be inferred as completely as the rest of the language.

You can see it in the following example.
\begin{caml_example}
let bump_twice bump x =
  bump (bump step:2 x);;
bump_twice bump 1;;
\end{caml_example}
While we intended "bump" to be of type "?step:int -> int -> int", it
is inferred as "'a -> step:int -> 'a". These two type being
incompatible, a type error occurs when applying "bump_twice" to
"bump".

We will not try here to explain in detail why such an erroneous type
is inferred. One must just understand that there is not enough
information in the above program to deduce the correct type of
"bump". That is, there is no way to know whether an argument is
optional or not, or which is the correct order, by looking only at how
a function is applied. The strategy used by the compiler is to assume
that there are no optional arguments, and that applications are done
in the right order.

The right way to solve this problem is to add a type annotation to
the argument "bump".
\begin{caml_example}
let bump_twice (bump : ?step:int -> int -> int) x =
  bump (bump step:2 x);;
bump_twice bump 1;;
\end{caml_example}
In practive, such problems appear mostly when using objects whose
methods have optional arguments, so that writing the type of object
arguments is often a good idea.

Normally the compiler will report a type error if you attempt to pass
to a function a parameter whose type is different from the expected
one, even if the difference is only in the order of labels. However,
in the specific case where the expected type is a non-labeled function
type, and the argument is a function expecting optional parameters,
the compiler will attempt to transform the argument to have it match
the expected type, by passing "None" for all optional parameters.

\begin{caml_example}
let twice f x = f(f x);;
twice bump 2;;
\end{caml_example}

This transformation is coherent with the intended semantics. That is,
if the application of optional parameters shall produce side-effects,
these are delayed until the received function is really applied to an
non-labeled argument.

\subsection{Suggestions for labeling}

Like for names, choosing labels for functions is not an easy task. A
good labeling is a labeling which

\begin{itemize}
\item makes programs more readable,
\item is easy to remember,
\item when possible, allows useful partial applications.
\end{itemize}

We explain here the rules we applied when labeling the standard library.

To speak in an ``object-oriented'' way, one can consider that each
function has a main argument, its {\em object}, and other arguments
related with its action, the {\em parameters}. To permit the
combination of functions through functionals in commuting label mode, the
object will not be labeled. Its role is clear by the function
itself. The parameters are labeled with keywords reminding either of
their nature or role. Best labels combine in their meaning nature and
role. When this is not possible the role is to prefer, since the nature will
often be given by the type itself. Obscure abbreviations should be
avoided.
\caml
\:List.map : fun:('a -> 'b) -> 'a list -> 'b list
\:output : out_channel -> buf:string -> pos:int -> len:int -> unit
\endcaml

When there are several objects of same nature and role, they are all
left unlabeled.
\caml
\:List.iter2 : fun:('a -> 'b -> 'c) -> 'a list -> 'b list -> unit
\endcaml

When there is no preferable object, all arguments are labeled.
\caml
\:Sys.rename : old:string -> new:string -> unit
\:String.blit :
\:  src:string -> src_pos:int -> dst:string -> dst_pos:int -> len:int -> unit
\endcaml

However, when there is only one argument, it is often left unlabeled.
\caml
\:Format.open_hvbox : int -> unit
\endcaml

Here are some of the label names you will find throughout the standard
library.

\begin{tableau}{|l|l|}{Label}{Meaning}
\entree{"pos:"}{a position in a list, string or array}
\entree{"len:"}{a length}
\entree{"buf:"}{a string used as buffer}
\entree{"src:"}{the source of an operation}
\entree{"dst:"}{the destination of an operation}
\entree{"fun:"}{a function to be applied}
\entree{"pred:"}{a boolean predicate}
\entree{"acc:"}{an accumulator}
\entree{"to:"}{an output channel}
\entree{"item:"}{a value in a collection}
\entree{"key:"}{a value used as index}
\entree{"data:"}{a value associated to an index}
\entree{"size:"}{a size parameter}
\entree{"mode:"}{an operation mode or a flag list}
\entree{"perm:"}{file permissions}
\end{tableau}

All these are only suggestions, but one shall keep in mind that the
choice of labels is essential for readability. Omissions or bizarre
choices will make the program difficult to maintain.

In the ideal, the right function name with right labels shall be
enough to understand the function's meaning. Since one can get this
information with OCamlBrowser or the ocaml toplevel, the documentation
is only used when a more detailed specification is needed.

\begin{caml_eval}
#label false;;
\end{caml_eval}


\section{Polymorphic variants}
\pdfsection{Polymorphic variants}

Variants as presented in section~\ref{s:tut-recvariants} are a
powerful tool to build data structures and algorithms. However they
sometimes lack flexibility when used in modular programming. This is
due to the fact every constructor reserves a name to be used with a
unique type. On cannot use the same name in another type, or consider
a value of some type to belong to some other type with more
constructors.

With polymorphic variants, this original assumption is removed. That
is, a variant tag does not belong to any type in particular, the type
system will just check that it is an admissible value according to its
use. You need not define a type before using a variant tag. A variant
type will be inferred independently for each of its uses.

\subsection*{Basic use}

In programs, polymorphic variants work like usual ones. You just have
to prefix their names with a backquote character "`".
\begin{caml_example}
[`On; `Off];;
`Number 1;;
let f = function `On -> 1 | `Off -> 0 | `Number n -> n;;
List.map fun:f [`On; `Off];;
\end{caml_example}
"[>`Off|`On] list" means that to match this list, you should at
least be able to match "`Off" and "`On", without argument.
"[<`On|`Off|`Number int]" means that "f" may be applied to "`Off",
"`On" (both without argument), or "`Number" $n$ where 
$n$ is an integer.
The ">" and "<" inside the variant type shows that they may still be
refined, either by defining more tags or allowing less. As such they
contain an implicit type variable. Both variant types appearing only
once in the type, the implicit type variables they constrain are not
shown.

The above variant types were polymorphic, allowing further refinement.
When writing type annotations, one will most often describe fixed
variant types, that is types that can be no longer refined. This is
also the case for type abbreviations. Such types do not contain "<" or
">", but just an enumeration of the tags and their associated types,
just like in a normal datatype definition. For conciseness, "of" is
omitted in polymorphic variant types.
\begin{caml_example}
type 'a vlist = [`Nil | `Cons 'a * 'a vlist];;
let rec map fun:f : 'a vlist -> 'b vlist = function
  | `Nil -> `Nil
  | `Cons(a, l) -> `Cons(f a, map fun:f l)
;;
\end{caml_example}

\subsection*{Advanced use}

Type-checking polymorphic variants is a subtle thing, and some
expressions may result in more complex type information.
\begin{caml_example}
function `A -> `B | x -> x;;
\end{caml_example}
Here the ".." means that we know that "`A" and "`B" may not have an
argument, but there is no specified upper bound on the number of
variant tags in this variant type. We know also that "`B" can appear
in the result, and input and output types have to be kept equal
because "x" is returned as is.

\begin{caml_example}
let f1 = function `A x -> x = 1 | `B -> true | `C -> false
let f2 = function `A x -> x = "a" | `B -> true ;;
let f x = f1 x && f2 x;;
\end{caml_example}
Here "f1" and "f2" both accept the variant tags "`A" and "`B", but the
argument of "`A" is "int" for "f1" and "string" for "f2". In "f"'s
type "`C", only accepted by "f1", disappears, but both argument types
appear for "`A" as "int & string". This means that if we
pass the variant tag "`A" to "f", its argument should be {\em both}
"int" and "string". Since there is no such value, "f" cannot be
applied to "`A", and "`B" is the only accepted input.

Even if a value has a fixed variant type, one can still give it a
larger type through coercions. Coercions are normally written with
both the source type and the destination type, but in simple cases the
source type may be omitted.
\begin{caml_example}
type 'a wlist = [`Nil | `Cons 'a * 'a wlist | `Snoc 'a wlist * 'a];;
let wlist_of_vlist  l = (l : 'a vlist :> 'a wlist);;
fun x -> (x :> [`A|`B|`C]);;
\end{caml_example}

You may also selectively coerce values through pattern matching.
\begin{caml_example}
let split_cases = function
  | `Nil | `Cons _ as x -> `A x
  | `Snoc _ as x -> `B x
;;
\end{caml_example}
When an or-pattern composed of variant tags is wrapped inside an
alias-pattern, the alias is given a type containing only the tags
enumerated in the or-pattern. this allows for many useful idioms, like
incremental definition of functions.

\begin{caml_example}
let num x = `Num x
let eval1 eval (`Num x) = x
let rec eval x = eval1 eval x ;;
let plus x y = `Plus(x,y)
let eval2 eval = function
  | `Plus(x,y) -> eval x + eval y
  | `Num _ as x -> eval1 eval x
let rec eval x = eval2 eval x ;;
\end{caml_example}

To make this even more confortable, you may use type definitions as
abbreviations for or-patterns. That is, if you have defined "type
myvariant = [`Tag1 int | `Tag2 bool]", then the pattern "#myvariant" is
equivalent to writing "(`Tag1(_ : int) | `Tag2(_ : bool))".
\begin{caml_eval}
type myvariant = [`Tag1 int | `Tag2 bool];;
\end{caml_eval}

Such abbreviations may be used alone,
\begin{caml_example}
let f = function
  | #myvariant -> "myvariant"
  | `Tag3 -> "Tag3";;
\end{caml_example}
or combined with with aliases.
\begin{caml_example}
let g1 = function `Tag1 _ -> "Tag1" | `Tag2 _ -> "Tag2";;
let g = function
  | #myvariant as x -> g1 x
  | `Tag3 -> "Tag3";;
\end{caml_example}
