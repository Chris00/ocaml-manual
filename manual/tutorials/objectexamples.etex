\chapter{Objects in Caml}
\label{c:objectexamples}
\pdfchapter{Tutorial: Objects in Caml}

{\it (Chapter written by Jérôme Vouillon and Didier Rémy)}

\bigskip

\noindent This chapter gives an overview of the object-oriented features of
Objective Caml.

\begin{htmlonly}

\ref{s:basic-examples} {\bf Basic examples} 

\ref{ss:classes-and-objects} Classes and objects \\
\ref{ss:reference-to-self} Reference to self \\
\ref{ss:initializers} Initializers \\
\ref{ss:virtual-methods} Virtual methods \\
\ref{ss:private-methods} Private methods \\
\ref{ss:class-interfaces} Class interfaces \\
\ref{ss:inheritance} Inheritance \\
\ref{ss:multiple-inheritance} Multiple inheritance \\
\ref{ss:parameterized-classes} Parameterized classes \\
\ref{ss:using-coercions} Using coercions \\
\ref{ss:functional-objects} Functional objects \\
\ref{ss:cloning-objects} Cloning objects \\
\ref{ss:recursive-classes} Recursive classes \\
\ref{ss:binary-methods} Binary methods \\
\ref{ss:friends} Friends \\

\ref{s:advanced-examples} {\bf Advanced examples} 

\ref{ss:bank-accounts} An extended example of bank accounts \\
\ref{ss:modules-as-classes} Simple modules as classes:
  \ref{module:string} Strings 
  \ref{module:stack} Stacks 
  \ref{module:hashtbl} Hash tables 
  \ref{module:set} Sets \\
\ref{ss:subject-observer} The subject/observer pattern \\

\end{htmlonly}

\section{Basic examples}
\label{s:basic-examples} 

\subsection{Classes and objects}
\label{ss:classes-and-objects} 

The class "point" has one instance variable "x" and two methods
"get_x" and "move". The initial value of the instance variable is "0".
The variable "x" is declared mutable, so the method "move" can change
its value.
\begin{caml_example} 
class point =
  object 
    val mutable x = 0
    method get_x = x
    method move d = x <- x + d
  end;;
\end{caml_example}

We now create a new point "p".
\begin{caml_example}
let p = new point;;
\end{caml_example}
Note that the type of "p" is "point". This is an abbreviation
automatically defined by the class definition above. It stands for the
object type "<get_x : int; move : int -> unit>", listing the methods
of class "point" along with their types.

Let us apply some methods to "p":
\begin{caml_example}
p#get_x;;
p#move 3;;
p#get_x;;
\end{caml_example}

The class "point" can also be abstracted over the initial values of
points.
\begin{caml_example} 
class point = fun x_init -> 
  object 
    val mutable x = x_init
    method get_x = x
    method move d = x <- x + d
  end;;
\end{caml_example}
As for declaration of functions, the above definition can be
abbreviated as:
\begin{caml_example}
class point x_init =
  object 
    val mutable x = x_init
    method get_x = x
    method move d = x <- x + d
  end;;
\end{caml_example}
An instance of the class point is now a function that expects an
initial parameter to create a point object:
\begin{caml_example}
new point;;
let p = new point 7;;
\end{caml_example}
The parameter "x_init" is, of course, visible in the whole body of the
definition, including methods. For instance, the method "get_offset"
in the class below returns the position of the object to the origin.
\begin{caml_example}
class point x_init =
  object 
    val mutable x = x_init
    method get_x = x
    method get_offset = x - x_init
    method move d = x <- x + d 
  end;;
\end{caml_example}
%Instance variables can only be used inside methods. For instance it would
%not be possible to define
%\begin{caml_example}
%class point x_init =
%  object 
%    val mutable x = x_init
%    val origin = x
%    method get_offset = x - origin
%    method move d = x <- x + d
%  end;;
%\end{caml_example}
Expressions can be evaluated and bound before defining the object body
of the class. This is useful to enforce invariants. For instance,
points can be automatically adjusted to grid as follows:
\begin{caml_example}
class adjusted_point x_init =
  let origin = (x_init / 10) * 10 in
  object 
    val mutable x = origin
    method get_x = x
    method get_offset = x - origin
    method move d = x <- x + d
  end;;
\end{caml_example}
(One could also raise an exception if the "x_init" coordinate is not
on the grid.) In fact, the same effect could here be obtained by
calling the definition of class "point" with the value of the
"origin".
\begin{caml_example}
class adjusted_point x_init =  point ((x_init / 10) * 10);;
\end{caml_example}
An alternative solution would have been to define the adjustement in 
a special allocation function:
\begin{caml_example}
let new_adjusted_point x_init = new point ((x_init / 10) * 10);;
\end{caml_example}
However, the former pattern is generally more appropriate, since 
the code for adjustment is part of the definition of the class and will be
inherited.

This ability provides class constructors as can be found in other
languages. Several constructors can be defined this way to build
objects of the same class but with different initialization patterns.


\subsection{Reference to self}
\label{ss:reference-to-self}

A method can also send messages to self (that is, the current object).  For
that, self must be explicitly bound, here to the variable "s" ("s" could be
any identifier, even though we will often choose the name "self".)
\begin{caml_example}
class printable_point x_init =
  object (s)
    val mutable x = x_init
    method get_x = x
    method move d = x <- x + d
    method print = print_int s#get_x
  end;;
let p = new printable_point 7;;
p#print;;
\end{caml_example}
Dynamically, the variable "s" is bound at the invocation of a method.  In
particular, when the class "printable_point" will be inherited, the variable
"s" will be correctly bound to the object of the subclass.  

\subsection{Initializers}
\label{ss:initializers}

Let-bindings within class definitions are evaluated before the object
is constructed. It is also possible to evaluate an expression
immediately after the object has been built. Such code is written as
an anonymous hidden method called an initializer. Therefore, is can
access self and the instance variables.
\begin{caml_example}
class printable_point x_init =
  let origin = (x_init / 10) * 10 in
  object (self)
    val mutable x = origin
    method get_x = x
    method move d = x <- x + d
    method print = print_int self#get_x
    initializer print_string "new point at "; self#print; print_newline()
  end;;
let p = new printable_point 17;;
\end{caml_example}
Initializers cannot be overriden. On the contrary, all intilializers are
evaluated sequentially. 
Initializers are particularly useful to enforce invariants. 
Another example can be see in section \ref{ss:bank:initializer}.


\subsection{Virtual methods}
\label{ss:virtual-methods}

It is possible to declare a method without actually defining it, using
the keyword "virtual".  This method will be provided latter in
subclasses. A class containing virtual methods must be flagged
virtual, and cannot be instantiated (that is, no object of this class
can be created). It still defines abbreviations (treating virtual methods
as other methods.)
\begin{caml_example}
class virtual abstract_point x_init =
  object (self)
    val mutable x = x_init
    method virtual get_x : int
    method get_offset = self#get_x - x_init
    method virtual move : int -> unit
  end;;
class point x_init =
  object
    inherit abstract_point x_init
    method get_x = x
    method move d = x <- x + d 
  end;;
\end{caml_example}

\subsection{Private methods}
\label{ss:private-methods}

Private methods are methods that do not appear in object interfaces.
They can only be invoked from other methods of the same object.
\begin{caml_example} 
class restricted_point x_init =
  object (self)
    val mutable x = x_init
    method get_x = x
    method private move d = x <- x + d
    method bump = self#move 1
  end;;
let p = new restricted_point 0;;
p#move 10;;
p#bump;;
\end{caml_example}
Private methods are inherited (they are by default visible in subclasses), 
unless they are hidden by signature matching, as described below.

Private methods can be made public in a subclass. 
\begin{caml_example} 
class point_again x =
  object (self)
    inherit restricted_point x
    method virtual move : _
  end;;
\end{caml_example}
The annotation "virtual" here is only used to mentioned a method without
providing its definition. An alternative definition is
\begin{caml_example} 
class point_again x =
  object (self : < move : _; ..> )
    inherit restricted_point x
  end;;
\end{caml_example}
One could think that a private method should remain private in a subclass. 
However, it since the method is visible in a subclass, it is always possible
pick it's code and define a method of the same name that run that code, so
yet another (heavier) solution would be:
\begin{caml_example} 
class point_again x =
  object (self : < move : _; ..> )
    inherit restricted_point x as super
    method move = super#move 
  end;;
\end{caml_example}

%XXX Parler de private virtual ?

\subsection{Class interfaces}
\label{ss:class-interfaces}


%XXX Differencier class type et interface de classe ?

Class interfaces are inferred from class definitions.  They may also
be defined directly and used to restrict the type of a class. As class
declarations, they also define a new type constructor.
\begin{caml_example}
class type restricted_point_type = 
  object
    method get_x : int
    method bump : unit
end;;
fun (x : restricted_point_type) -> x;;
\end{caml_example}
In addition to documentation, these class interfaces can be used to
constrain the type of a class. Both instance variables and concrete
private methods can be hidden by a class type constraint. Public and
virtual methods, however, cannot. 
\begin{caml_example}
class restricted_point' x = (restricted_point x : restricted_point_type);;
\end{caml_example}
Or, equivalently:
\begin{caml_example}
class restricted_point' = (restricted_point : int -> restricted_point_type);;
\end{caml_example}
The interface of a class can also be specified in a module
signature, and used to restrict the inferred signature of a module. 
\begin{caml_example}
module type POINT = sig 
  class restricted_point' : int ->
    object    
      method get_x : int
      method bump : unit
    end 
end;;
module Point : POINT = struct 
  class restricted_point' = restricted_point
end;;
\end{caml_example}

\subsection{Inheritance}
\label{ss:inheritance}

We illustrate inheritance by defining a class of colored points that
inherits from the class of points.  This class has all instance
variables and all methods of class "point", plus a new instance
variable "c" and a new method "color".
\begin{caml_example}
class colored_point x (c : string) =
  object 
    inherit point x
    val c = c
    method color = c
  end;;
let p' = new colored_point 5 "red";;
p'#get_x, p'#color;;
\end{caml_example}
A point and a colored point have incompatible types, since a point has
no method "color". However, the function "get_x" below is a generic
function applying method "get_x" to any object "p" that has this
method (and possibly some others, which are represented by an ellipsis
in the type). Thus, it applies to both points and colored points.
\begin{caml_example}
let get_succ_x p = p#get_x + 1;;
get_succ_x p + get_succ_x p';;
\end{caml_example}
Methods need not be declared previously, as shown by the example:
\begin{caml_example}
let set_x p = p#set_x;;
let incr p = set_x p (get_succ_x p);;
\end{caml_example}

\subsection{Multiple inheritance}
\label{ss:multiple-inheritance}

Multiple inheritance is allowed. Only the last definition of a method
is kept: the redefinition in a subclass of a method that was visible in
the parent class overrides the definition in the parent class.
Previous definitions of a method can be reused by binding the related
ancestor. Below, "super" is bound to the ancestor "printable_point".
The name "super" is not actually a variable and can only be used to
select a method as in "super#print".
\begin{caml_example}
class printable_colored_point y c = 
  object (self)
    val c = c
    method color = c
    inherit printable_point y as super
    method print =
      print_string "(";
      super#print;
      print_string ", ";
      print_string (self#color);
      print_string ")"
  end;;
let p' = new printable_colored_point 17 "red";;
p'#print;;
\end{caml_example}
A private method that has been hidden in the parent class is no more
visible, and is thus not overriden. This also applies to initializers:
all initializers along the class hierachy are evaluated, in the order
they are introduced.

\subsection{Parameterized classes}
\label{ss:parameterized-classes}

Reference cells can also be implemented as objects.
The naive definition fails to typecheck:
\begin{caml_example}
class ref x_init =
  object 
    val mutable x = x_init
    method get = x
    method set y = x <- y
  end;;
\end{caml_example}
The reason is that at least one of the methods has a polymorphic type
(here, the type of the value stored in the reference cell), thus the
class should be parametric, or the method type should be constrained
to a monomorphic type.  A monomorphic instance of the class could
be defined by:
\begin{caml_example}
class ref (x_init:int) =
  object 
    val mutable x = x_init
    method get = x
    method set y = x <- y
  end;;
\end{caml_example}
A class for polymorphic references must explicitly list the type
parameters in its declaration. Class type parameters are always listed
between "[" and "]". The type parameters must also be bound somewhere
in the class body by a type constraint.
\begin{caml_example}
class ['a] ref x_init = 
  object 
    val mutable x = (x_init : 'a)
    method get = x
    method set y = x <- y
  end;;
let r = new ref 1 in r#set 2; (r#get);;
\end{caml_example}
The type parameter in the declaration may actually be constrained in the
body of the class definition. In the class type, the actual value of
the type parameter is displayed in the "constraint" clause. 
\begin{caml_example}
class ['a] ref_succ (x_init:'a) = 
  object
    val mutable x = x_init + 1
    method get = x
    method set y = x <- y
  end;;
\end{caml_example}
Let us consider a more realistic example.  We put an additional type
constraint in method "move", since no free variables must remain uncaptured
by a type parameter.
\begin{caml_example}
class ['a] circle (c : 'a) =
  object 
    val mutable center = c
    method center = center
    method set_center c = center <- c
    method move = (center#move : int -> unit)
  end;;
\end{caml_example}
An alternate definition of "circle", using a "constraint" clause in
the class definition, is shown below. The type "#point" used below in
the "constraint" clause is an abbreviation produced by the definition
of class "point". This abbreviation unifies with the type of any
object belonging to a subclass of class "point". It actually expands to
"< get_x : int; move : int -> unit; .. >". This leads to the following
alternate definition of "circle", which has slightly stronger
constraints on its argument, as we now expect "center" to have a
method "get_x".
\begin{caml_example}
class ['a] circle (c : 'a) =
  object 
    constraint 'a = #point
    val mutable center = c
    method center = center
    method set_center c = center <- c
    method move = center#move
  end;;
\end{caml_example}
The class "colored_circle" is a specialized version of class
"circle" which requires the type of the center to unify with
"#colored_point", and adds a method "color". Note that when specializing a
parameterized class, the instance of type parameter must always be
explicitly given. It is again written inside "[" and "]". 
\begin{caml_example}
class ['a] colored_circle c =
  object
    constraint 'a = #colored_point
    inherit ['a] circle c
    method color = center#color
  end;;
\end{caml_example}

\subsection{Using coercions}
\label{ss:using-coercions}

Subtyping is never implicit.  There are, however, two ways to perform
subtyping.  The most general construction is fully explicit: both the
domain and the codomain of the type coercion must be given.

We have seen that points and colored points have incompatible types.
For instance, they cannot be mixed in the same list. However, a
colored point can be coerced to a point, hiding its "color" method:
\begin{caml_example}
let colored_point_to_point cp = (cp : colored_point :> point);;
let p = new point 3 and q = new colored_point 4 "blue";;
let l = [p; (colored_point_to_point q)];;
\end{caml_example}
An object of type "t" can be seen as an object of type "t'" 
only if "t" is a subtype of "t'". For instance, a point cannot be
seen as a colored point. 
\begin{caml_example}
(p : point :> colored_point);;
\end{caml_example}
Indeed, backward coercions are unsafe, and should be combined with a type case,
possibly raising a runtime error.  However, there is no such operation
available in the language. 

Be aware that subtyping and inheritance are not related.  Inheritance is a
syntactic relation between classes while subtyping is a semantic relation
between types.  For instance, the class of colored points could have been
defined directly, without inheriting from the class of points; the type of
colored points would remain unchanged and thus still be a subtype of
points.
% Conversely, the class "int_comparable" inherits from class
%"comparable", but type "int_comparable" is not a subtype of "comparable".
%\begin{caml_example}
%function x -> (x : int_comparable :> comparable);;
%\end{caml_example}

The domain of a coercion can usually be omitted. For instance, one can
define:
\begin{caml_example}
let to_point cp = (cp :> point);;
\end{caml_example}
In this case, the function "colored_point_to_point" is an instance of the 
function "to_point". This is not always true, however. The fully
explicit coercion  is more precise and is sometimes  unavoidable. 
Here is an example where the shorter form fails:
\begin{caml_example}
class virtual c  = object method virtual m : c end;;
class c'  =
  object (self)
    inherit c 
    method m = (self :> c)
    method m' = 1
end;;
\end{caml_example}

The  type of the coercion to type "c" can be seen here:
\begin{caml_example}
function x -> (x :> c);;
\end{caml_example}
As class "c'"
inherits from class "c", its method "m" must have type "c". On the
other hand, in expression "(self :> c)"  the type of "self"
and the domain of the coercion above must be unified. 
That is, the type of the method "m" in "self" (i.e. "c") is
also the type of "self". So, the type of "self" is "c". 
This is a contradiction, as the type of "self" has a
method "m'", whereas type "c" does not.

The desired coercion of type "<m : c;..> -> c" can be obtained by
using a fully explicit coercion:
\begin{caml_example}
function x -> (x : #c :> c);;
\end{caml_example}
Thus one can define class c' as follows:
\begin{caml_example}
class c'  =
  object (self)
    inherit c 
    method m = (self : #c :> c)
    method m' = 1
  end;;
\end{caml_example}
An alternative is to define class "c" this way (of course
this definition is not equivalent to the previous one):
\begin{caml_example}
class virtual c = object (_ : 'a) method virtual m : 'a end;;
\end{caml_example}
Then, a coercion operator is not even required.
\begin{caml_example}
class c' = object (self) inherit c  method m = self method m' = 1 end;;
\end{caml_example}
Here, the simple coercion operator "(e :> c)" can be used to
coerce an object expression "e" from type "c'" to type "c". 
Semi-implicit coercions are actually defined so
as to work correctly with classes returning "self". 
% without coercion.
\begin{caml_example}
(new c' :> c);;
\end{caml_example}

Another common problem may occur when one tries to define a coercion to a
class "c" inside the definition of class "c". The problem is due to the type
abbreviation not being completely defined yet, and so its subtypes are not
clearly known.  Then, a coercion "(_ : #c :> c)" is taken to be 
the identity function, as in
\begin{caml_example}
function x -> (x :> 'a);;
\end{caml_example}
As a consequence, if the coercion is applied to "self", as in the
following example, the type of "self" is unified with the closed type
"c" (a closed object type is an object type without ellipsis).  This
would constrains the type of self be closed and is thus rejected.
Indeed, the type of self cannot be closed: this would prevent any
further extension of the class. Therefore, a type error is generated
when the unification of this type with another type would result in a
closed object type.
\begin{caml_example}
class c = object (self) method m = (self : #c :> c) end;;
\end{caml_example}
This problem can sometimes be avoided by first defining the abbreviation, 
using a class type:
\begin{caml_example}
class type c0 = object method m : c0 end;;
class c : c0 = object (self) method m = (self : #c0 :> c0) end;;
\end{caml_example}
It is also possible to use a virtual class. Inheriting from this class
simultaneously allows to enforce all methods of "c" to have the same
type as the methods of "c0".
\begin{caml_example}
class virtual c0 = object method virtual m : c0 end;;
class c = object (self) inherit c0 method m = (self : #c0 :> c0) end;;
\end{caml_example}
One could think of defining the type abbreviation directly:
\begin{caml_example}
type c1 = <m : c1>;;
\end{caml_example}
However, the abbreviation "#c1" cannot be defined this way (the
abbreviation "#c0" is defined from the class "c0", not from the type
"c0"), and should be expanded:
\begin{caml_example}
class c = object (self)  method m = (self : <m : c1; ..> as 'a :> c1) end;;
\end{caml_example}

\subsection{Functional objects}
\label{ss:functional-objects}

It is possible to write a version of class "point" without assignments
on the instance variables. The construct "{< ... >}" returns a copy of
``self'' (that is, the current object), possibly changing the value of
some instance variables.
\begin{caml_example}
class functional_point y =
  object 
    val x = y
    method get_x = x
    method move d = {< x = x + d >}
  end;;
let p = new functional_point 7;;
p#get_x;;
(p#move 3)#get_x;;
p#get_x;;
\end{caml_example}
Note that the type abbreviation "functional_point" is recursive, which can
be seen in the class type of "functional_point": the type of self to "'a"
and "'a" appears inside the type of the "move" method.

The above definition of "functional_point" is not equivalent
with the following: 
\begin{caml_example}
class bad_functional_point y =
  object 
    val x = y
    method get_x = x
    method move d = new functional_point (x+d)
  end;;
let p = new functional_point 7;;
p#get_x;;
(p#move 3)#get_x;;
p#get_x;;
\end{caml_example}
While objects of either class will behave the same, objects of their
subclasses will be different. In a subclass of later, the move method will
keep returning an object of the parent class.  On the contrary, in a
subclass of the former, the move method will return an object of the
subclass.

Functional update is often used in conjunction with binary methods
as illustrated in section \ref{module:string}.

\subsection{Cloning objects}
\label{ss:cloning-objects}

Objects can also be cloned, whether they are functional or imperative.
The library function "Oo.copy" makes a shallow copy of an object. That is, 
it returns an object that is equal to the previous one. The 
instance variables have been copied but their contents are shared.
Assigning a new value to an instance variable of the copy (using a method
call) will not affect instance variables of the original, and conversely. 
A deeper assigned (for example if the instance variable if a reference cell) 
will of course affect both the original and the copy. 

The type of "Oo.copy" is the following:
\begin{caml_example}
Oo.copy;;
\end{caml_example}
The keyword "as" in that type binds the type variable "'a" to
the object type "< .. >".  Therefore, "Oo.copy" takes an object with
any methods (represented by the ellipsis), and returns an object of
the same type. The type of "Oo.copy" is different from type "< .. > ->
< .. >" as each ellipsis represents a different set of methods.
Ellipsis actually behaves as a type variable.
\begin{caml_example}
let p = new point 5;;
let q = Oo.copy p;;
q#move 7; (p#get_x, q#get_x);;
\end{caml_example}
In fact, "Oo.copy p" will behave as "p#copy" assuming that a public
method "copy" with body "{< >}" has been defined in the class of "p".

Objects can be compared using the generic comparison functions ("=",
"<", ...).  Two objects are equal if and only if they are physically
equal. In particular, an object and its copy are not equal.
\begin{caml_example}
let q = Oo.copy p;;
p = q, p = p;;
\end{caml_example}

Cloning and override have a non empty intersection.
They are intercheangeable when used withing an object and without 
overrding any field:
\begin{caml_example}
class copy =
  object
    method copy = {< >}
  end;;
class copy =
  object (self)
    method copy = Oo.copy self
  end;;
\end{caml_example}
Only the override can be used to actially override fields, and 
only the "Oo.copy" primitive can be used externally. 

Cloning can also be used to provide a facilities.
\begin{caml_example}
class backup = 
  object (self : 'mytype)
    val mutable copy = None
    method save = copy <- Some {< copy = None >}
    method restore = match copy with Some x -> x | None -> self
  end;;
\end{caml_example}
The above will only save one level. 
\begin{caml_example}
class ['a] backup_ref x = object inherit ['a] ref x inherit backup end;;
let rec get p n = if n = 0 then p # get else get (p # restore) (n-1);;
let p = new backup_ref 0  in
p # save; p # set 1; p # save; p # set 2; 
[get p 0; get p 1; get p 2; get p 3; get p 4];;
\end{caml_example}
A variant can retain all copies. (We add a method clear to manually erase
all copies so that old version can be garbage collected.)
\begin{caml_example}
class backup = 
  object (self : 'mytype)
    val mutable copy = None
    method save = copy <- Some {< >}
    method restore = match copy with Some x -> x | None -> self
    method clear = copy <- None
  end;;
\end{caml_example}
\begin{caml_example}
class ['a] backup_ref x = object inherit ['a] ref x inherit backup end;;
let p = new backup_ref 0  in
p # save; p # set 1; p # save; p # set 2; 
[get p 0; get p 1; get p 2; get p 3; get p 4];;
\end{caml_example}



\subsection{Recursive classes}
\label{ss:recursive-classes}

Recursive classes can be used to define objects whose types are
mutually recursive.
\begin{caml_example}
class window =
  object 
    val mutable top_widget = (None : widget option)
    method top_widget = top_widget
  end
and widget (w : window) =
  object
    val window = w
    method window = window
  end;;
\end{caml_example}
Although their types are mutually recursive, the classes "widget" and 
"window" are themselves independent. 


\subsection{Binary methods}
\label{ss:binary-methods}

A binary method is a method which takes an argument of the same type
as self. The class "comparable" below is a template for classes with a
binary method "leq" of type "'a -> bool" where the type variable "'a"
is bound to the type of self. Therefore, "#comparable" expands to "<
leq : 'a -> bool; .. > as 'a".  We see here that the binder "as" also
allows to write recursive types.
\begin{caml_example}
class virtual comparable = 
  object (_ : 'a)
    method virtual leq : 'a -> bool
  end;;
\end{caml_example}
We then define a subclass "money" of "comparable". The class money 
simply wraps floats as comparable objects. We will extend it below with
more operations. There is a type constraint on the class parameter "x"
as the primitive "<=" is a polymorphic comparison function in
Objective Caml.  The "inherit" clause ensures that the type of objects
of this class is an instance of "#comparable".
\begin{caml_example}
class money (x : float) =
  object
    inherit comparable
    val repr = x
    method value = repr
    method leq p = repr <= p#value
  end;;
\end{caml_example}
% pas expliqué: la mutabilite peut être cachée
Note that the type "money1" is not a subtype of type
"comparable", as the self type appears in contravariant position
in the type of method "leq".
Indeed, an object "m" of class "money" has a method "leq"
that expects an argument of type "money" since it accesses
its "value" method.  Considering "m" of type "comparable" would allow to
call method "leq" on "m" with an argument that does not have a method
"value", which would be an error.

Objects of class "money2" below also print the value they hold. Similarly
the type "money2" is not a subtype of type "money".
\begin{caml_example}
class money2 x =
  object   
    inherit money x
    method times k = {< repr = k *. repr >}
  end;;
\end{caml_example}
It is however possible to define functions that manipulate objects of
type either "money" or "money2": the function "min"
will return the minimum of any two objects whose type unifies with
"#comparable". The type of "min" is not the same as "#comparable ->
#comparable -> #comparable", as the abbreviation "#comparable" hides a
type variable (an ellipsis). Each occurrence of this abbreviation
generates a new variable.
\begin{caml_example}
let min (x : #comparable) y =
  if x#leq y then x else y;;
\end{caml_example}
This function can be applied to objects of type "money"
or "money2".
\begin{caml_example}
(min (new money  1.3) (new money 3.1))#value;;
(min (new money2 5.0) (new money2 3.14))#value;;
\end{caml_example}

More examples of binary methods can be found in section
\ref{module:string} and \ref{module:set}.

Note the use of functional update for method "times". 
Writing  "new money2 (k *. repr) >}" instead of  "{< repr = k *. repr >}"
would not behave well with inheritance: in a subclass "money3" of "money2"
the "times" method would return an object of class "money2" but not of class
"money3" as would be expected. 

The class "money" could naturally cary another binary method. Here is a
fool, direct definition:
\begin{caml_example}
class money x =
  object (self : 'a)
    val repr = x
    method value = repr
    method print = print_float repr
    method times k = {< repr = k *. x >}
    method leq (p : 'a) = repr <= p#value
    method plus (p : 'a) = {< repr = x +. p#value >}
  end;;
\end{caml_example}

\subsection{Friends}
\label{ss:friends}

The above class "money" reveals a problem that often occurs with binary
methods.  In order to interact with other objects of the same class, the 
representaion of the money had to be reveal as a method "value". 
Note that if we removed the two binary methods "plus" and "leq", the
representation of the money could be hidden inside objects by 
removing the method "value" as well. 
\begin{caml_example}
class safe_money x =
  object (self : 'a)
    val repr = x
    method print = print_float repr
    method times k = {< repr = k *. x >}
  end;;
\end{caml_example}
Here the representation of the object is known only to a particular object.
To make it available to other objects of the same class, one is force to
make it available to the whole world. However one can easily restrict the
world using the module system and hide the representation to the rest of the
universe.
\begin{caml_example}
module type MONEY = 
  sig 
    type t
    class c : float -> 
      object ('a)
        val repr : t
        method value : t
        method print : unit
        method times : float -> 'a
        method leq : 'a -> bool
        method plus : 'a -> 'a 
      end
  end;;
module Euro : MONEY = 
  struct
    type t = float
    class c x =
      object (self : 'a)
        val repr = x
        method value = repr
        method print = print_float repr
        method times k = {< repr = k *. x >}
        method leq (p : 'a) = repr <= p#value
        method plus (p : 'a) = {< repr = x +. p#value >}
      end
  end;;
\end{caml_example}
Another example of friend functions may be found in section
\ref{module:set}.  These examples occur when a group of objects (here
objects of the same class) and function should see each others internal
representation, while their representation should be hidden from the
outside. The solution is always to define all friends in the same module,
give access to the representation and use a signature constraint to make the
representation abstract outside of the module.



\section{Advanced examples}
\label{s:advanced-examples} 

In this section we show slightly more realistic examples.  We review many of
the features simultaneously througg the example fo a bank accounty.  We show
how modules taken from the library can be turned into classes.  
Last, we describe a programming pattern know of as {\em virtual types}
through an example of window managers.



\subsection{An extended example of bank accounts}
\label{ss:bank-accounts}

In this section, we illustrate most aspects of Object and inheritance
by refinining, debuging, and specilazing the following 
initial naive definition of a simple bank account. 
\begin{caml_example}
let euro = new Euro.c;;
let zero = euro 0.;;
let neg x = x#times (-1.);;
class account =
  object 
    val mutable balance = zero
    method balance = balance
    method deposit x = balance <- balance # plus x
    method retrieve x =
      if x#leq balance then (balance <- balance # plus (neg x); x) else zero
  end;;
let c = new account in c # deposit (euro 100.); c # retrieve (euro 50.);;
\end{caml_example}
One may refined this definition with a method to compute interests
\begin{caml_example}
class account_with_interests =
  object (self)
    inherit account
    method private interests = self # deposit (self # balance # times 0.03)
  end;;
\end{caml_example}
We made the interest method private, since clearly the method interest
should not be freely called. Here, it is only made accessible to subclasses
that will manage monthly or  yearly updates of the account. 

We should soon fix a bug in the current definition: The deposit method can
be used for retrieve by depositing negative amounts. We can fix this
directly:
\begin{caml_example}
class safe_account =
  object
    inherit account
    method deposit x = if zero#leq x then balance <- balance#plus x
  end;;
\end{caml_example}
However, the bug might be fixed more safely by  the following definition:
\begin{caml_example}
class safe_account =
  object
    inherit account as unsafe
    method deposit x =
      if zero#leq x then unsafe # deposit x
      else raise (Invalid_argument "deposit")
  end;;
\end{caml_example}
In particular, this does not require the knowledge of the implementation of 
the metod "deposit".

To keep of trace of operations, extend the class with a mutable field
"history" and a private method "trace" to add an operation in the
register. Then each method to be traced is redefined.
\begin{caml_example}
type 'a operation = Deposit of 'a | Retrieval of 'a;;
class account_with_history =
  object (self) 
    inherit safe_account as super  
    val mutable history = []
    method private trace x = history <- x::history
    method deposit x = self#trace (Deposit x);  super # deposit x
    method retrieve x = self#trace (Retrieval x); super # retrieve x
    method history = List.rev history
  end;;
\end{caml_example}
\label{ss:bank:initializer}
One may wish to open an account and simultaneously deposit some initial
amount. Althought,  this has not been though initially, it can be achieve by
using an initializer
\begin{caml_example}
class account_with_deposit x =
  object 
    inherit account_with_history 
    initializer balance <- x 
  end;;
\end{caml_example}
or better
\begin{caml_example}
class account_with_deposit x =
  object (self)
    inherit account_with_history 
    initializer self # deposit x
  end;;
\end{caml_example}
Indeed, the later is safer since the call to deposit will automatically
benefit from safety checks and from the trace.
\begin{caml_example}
class account_with_deposit x =
  object (self)
    inherit account_with_history 
    initializer self # deposit x
  end;;
\end{caml_example}
Here is an example
\begin{caml_example}
let ccp = new account_with_deposit (euro 100.) in 
ccp # retrieve (euro 50.); ccp # history;;
\end{caml_example}
Closing an account can be done with the following polyrmorphic function:
\begin{caml_example}
let close c = c # retrieve (c # balance);;
\end{caml_example}
Of course, this applies to all sorts of accounts. 

Finally, we gather several version of the account into a module "Account"
abstracted other some currency.
\begin{caml_example}
let today () = (01,01,2000)
module Account (M:MONEY) =
  struct
    type m = M.c
    let m = new M.c
    let zero = m 0. 
        
    class bank =
      object (self) 
        val mutable balance = zero
        method balance = balance
        val mutable history = []
        method private trace x = history <- x::history
        method deposit x =
          self#trace (Deposit x);
          if zero#leq x then balance <- balance # plus x
          else raise (Invalid_argument "deposit")
        method retrieve x =
          if x#leq balance then
            (balance <- balance # plus (neg x); self#trace (Retrieval x); x)
          else zero
        method history = List.rev history
      end
        
    class type client_view = 
      object
        method deposit : m -> unit
        method history : m operation list
        method retrieve : m -> m
        method balance : m
      end
          
    class virtual check_client x = 
      let y = if (m 100.)#leq x then x
      else raise (Failure "Insuffisant initial deposit") in
      object (self) initializer self#deposit y end
        
    module Client (B : sig class bank : client_view end) =
      struct
        class account x : client_view =
          object
            inherit B.bank
            inherit check_client x
          end
            
        let discount x =
          let c = new account x in
          if today() < (1998,10,30) then c # deposit (m 100.); c
      end
  end;;
\end{caml_example}
This shows the use of modules to group several class definitions that can in
fact be thought of as a single unit.  This unit would be provided by a bank
for both internal and external use.  
This is implementated as a functor that asbtracts over the currency so that
the same code can be used to provide accounts in different currency. 

The class "bank" is the {\em real} implementation of the bank account (it
could have been inlined). This is the one that will be used for further
extensions, refinement, etc.  The client will only be given the client view.
\begin{caml_example}
module Euro_account = Account(Euro);;
module Client = Euro_account.Client (Euro_account);;
new Client.account (new Euro.c 100.);;
\end{caml_example}
Hence, the client does not have direct access to the "balance", nor the
"history" if his account. His only way to change his balance is to make a
deposit or a retrieval.  It is important to give the client a class an not
just the ability to create account (such as the promotional "discount"
account), so that he can himself defined personalized client account. 
For instance, the client may refine the  "deposit" and "retrieve" methods 
so as to do his own financial bookkeeping, automatically.
On the other end, the method "discount" is given as such, with no
possibility for further personalization.

It is important that the client's view has been defined as a functor
"Client" in order to keep the ability to build client accounts while
refining the "bank". The functor "Client" may remain unchanged and be passed
the new definition to intiliazed a client's view of the extended account.
\begin{caml_example}
module Investment_account (M : MONEY) = 
  struct
    type m = M.c
    module A = Account(M)
        
    class bank =
      object
        inherit A.bank as super
        method deposit x =
          if (new M.c 1000.)#leq x then
            print_string "Would you like to invest?";
          super # deposit x
      end
        
    module Client = A.Client
  end;;
\end{caml_example}
\begin{caml_eval}
module Euro_account = Internet_account (Euro);;
module Client = Euro_account.Client (Euro_account);;
new Client.account (new Euro.c 100.);;
\end{caml_eval}
The functor "Client" may also be redefined when some new features of the
account can be given to the client. For instance,
\begin{caml_example}
module Internet_account (M : MONEY) = 
  struct
    type m = M.c
    module A = Account(M)

    class bank =
      object
        inherit A.bank 
        method mail s = print_string s
      end
        
    class type client_view = 
      object
        method deposit : m -> unit
        method history : m operation list
        method retrieve : m -> m
        method balance : m
        method mail : string -> unit
      end
          
    module Client (B : sig class bank : client_view end) =
      struct
        class account x : client_view =
          object
            inherit B.bank
            inherit A.check_client x
          end
      end
  end;;
\end{caml_example}
\begin{caml_eval}
module Euro_account = Internet_account (Euro);;
module Client = Euro_account.Client (Euro_account);;
new Client.account (new Euro.c 100.);;
\end{caml_eval}


\subsection{Simple modules as classes}
\label{ss:modules-as-classes}

One may wonder whether it is possible to treat primitive types such as
intergers and strings as objects. Although this usually uninteresting
for intergers or strings, there maybe be a few situations when
this is meaningful. The "money" class above is an example. 
We show here how to do it for strings. 

\subsubsection{Strings}
\label{module:string}

A naive definition of strings could be:
\begin{caml_example}
class ostring s =
  object
     method get n = String.get n
     method set n c = String.set n c
     method print = print_string s
     method copy = new ostring (String.copy s)
  end;;
\end{caml_example}
However, the method "copy" returns an object of the class string, and not an
objet of the current class. Hence, if the class is further extended, the
method "copy" will only return an object of the parent class.
\begin{caml_example}
class sub_string s =
  object
     inherit ostring s
     method sub start len = new sub_string (String.sub s  start len)
  end;;
\end{caml_example}
As seen in section \ref{ss:binary-methods}, the solution is to use
functional update instead. One need to make an explicit instance variable
containing the representation "s" of the string.
\begin{caml_example}
class better_string s =
  object
     val repr = s
     method get n = String.get n
     method set n c = String.set n c
     method print = print_string repr
     method copy = {< repr = String.copy repr >}
     method sub start len = {< repr = String.sub s  start len >}
  end;;
\end{caml_example}
As shown in the inferred type, the "copy" and "sub" now return objects of
the same type as the type of the class.

Another difficulty is the implementation of the method "concat". 
In order to concatenate a string with another string of the same class, 
one must be able to access the instance variable externally. Thus, a method
"repr" returning s must be defined. Here is the new definition
\begin{caml_example}
class ostring s =
  object (self : 'mytype)
     val repr = s
     method repr = repr
     method get n = String.get n
     method set n c = String.set n c
     method print = print_string repr
     method copy = {< repr = String.copy repr >}
     method sub start len = {< repr = String.sub s start len >}
     method concat (t : 'mytype) = {< repr = repr ^ t#repr >}
  end;;
\end{caml_example}
Another constructor of the class string can be defined to return an
uninitialized string of a given length
\begin{caml_example}
class cstring n = ostring (String.create n);;
\end{caml_example}
Here, exposing the representation of strings is probably harmless, and we do
not need to hide as we did for the class money in section \ref{ss:friends}


\subsubsection{Stacks}
\label{module:stack}

There is sometime an alternative between using modules or classes for
parametric data types. 
Indeed, there are situations when the two approaches are quite similar. 
For instance, a stack can be  straightforwardly implemented as a class:
\begin{caml_example}
exception Empty;;
class ['a] stack =
  object 
    val mutable l = ([] : 'a list)
    method push x = l <- x::l
    method pop = match l with [] -> raise Empty | a::l' -> l <- l'; a
    method clear = l <- []
    method length = List.length l
  end;;
\end{caml_example}
However, writing a method for iterating over a stack is more
problematic.  A method "fold" would have type
"('b -> 'a -> 'b) -> 'b -> 'b". Here "'a" is the parameter of the stack.
The parameter "'b" is not related to the class "'a stack" but to the
argument that will be passed to the method "fold".
The intuition is that method "fold" should be polymorphic, i.e. of type 
"All ('a) ('b -> 'a -> 'b) -> 'b -> 'b", which  is not currently possible.
One possibility would be to make "'b" an extra parameter of class "stack"
\begin{caml_example}
class ['a, 'b] stack2 =
  object
    inherit ['a] stack
    method fold f (x : 'b) = List.fold_left f x l
  end;;
\end{caml_example}
However,  method "fold" of a given object can only be
applied to functions that all have the same type:
\begin{caml_example}
let s = new stack2;;
s#fold (+) 0;;
s;;
\end{caml_example}
The best solution would be to make method "fold" polymorphic. 
However Ocaml does not currently allow methods to be polymorphic. 

Thus, the current solution is to leave the function "fold" outside of
the class.
\begin{caml_example}
class ['a] stack3 =
  object
    inherit ['a] stack
    method iter f = List.iter (f : 'a -> unit) l
  end;;
let stack_fold (s : 'a #stack3) f x =
  let accu = ref x in
  s#iter (fun e -> accu := f !accu e);
  !accu;;
\end{caml_example}

% However, the nice correspondence between the implementations of stacks as 
% modules or classes is a very particular case. 

% XXX Maps

\subsubsection{Hashtbl}
\label{module:hashtbl}

A simplified version of an object-oriented hash table should have the
following class type.
\begin{caml_example}
class type ['a, 'b] hash_table =
  object 
    method find : 'a -> 'b
    method add : 'a -> 'b -> unit
  end;;
\end{caml_example}
A simple implementation, which is quite reasonable for small hastable is
just to use an association list:
\begin{caml_example}
class ['a, 'b] small_hashtbl : ['a, 'b] hash_table =
  object
    val mutable table = []
    method find key = List.assoc key table
    method add key valeur = table <- (key, valeur) :: table
  end;;
\end{caml_example}
A better implementation, and one that scales up will us a true hash table...
whose elements are a small hash table!
\begin{caml_example}
class ['a, 'b] hashtbl size : ['a, 'b] hash_table =
  object (self)
    val table = Array.init size (fun i -> new small_hashtbl) 
    method private hash key =
      (Hashtbl.hash key) mod (Array.length table)
    method find key = table.(self#hash key) # find key
    method add key = table.(self#hash key) # add key
  end;;
\end{caml_example}

% problem 

% solution

\subsubsection{Sets}
\label{module:set}

Implementing sets leads to another difficulty.  Indeed, the method
"union" needs to be able to access the internal representation of
another object of the same class.  

This is another instance of friend functions as seen in section
\ref{ss:friends}. Indeed, this is the same mechanism used in the module
"Set" in the absence of objects.

In the object-oriented version of set, we only need to add an aditional 
method "tag" to return the representation of a set. Since "set" are
parametric. The method "tag" has a parametric type "'a tag", concrete within 
the module definition but abstract in its signature.
From outside, it will them be garanteed that two objects with a method "tag" 
of the same type will share the same representation.
\begin{caml_example}
module type SET =
  sig
    type 'a tag
    class ['a] c :
      object ('b)
        method is_empty : bool
        method mem : 'a -> bool
        method add : 'a -> 'b
        method union : 'b -> 'b
        method iter : ('a -> unit) -> unit
        method tag : 'a tag
      end
  end;;
module Set : SET =
  struct
    let rec merge l1 l2 =
      match l1 with
        [] -> l2
      | h1 :: t1 ->
          match l2 with
            [] -> l1
          | h2 :: t2 ->
              if h1 < h2 then h1 :: merge t1 l2
              else if h1 > h2 then h2 :: merge l1 t2
              else merge t1 l2
    type 'a tag = 'a list
    class ['a] c =
      object (_ : 'b)
        val repr = ([] : 'a list)
        method is_empty = (repr = [])
        method mem x = List.exists ((=) x) repr
        method add x = {< repr = merge [x] repr >}
        method union (s : 'b) = {< repr = merge repr s#tag >}
        method iter (f : 'a -> unit) = List.iter f repr
        method tag = repr
      end
  end;;
\end{caml_example}



\subsection{The subject/observer pattern}
\label{ss:subject-observer}

The following example, known as the subject/observer pattern, is often
presented in the litterature as a difficult inheritance problem with
inter-connected classes.
The general pattern amounts to the definition a pair of two
classes that recusively interact with one another.  

The class "observer"  has a distinguished method "notify" that requires 
two arguments, a subject and an event to excecute an action. 
\begin{caml_example}
class virtual ['subject, 'event] observer =
  object
    method virtual notify : 'subject ->  'event -> unit
  end;;
\end{caml_example}
The class "subject" remembers a list of oberservers in an instance variable,
and has a distinguished method "notify_observers" to broadcast the message
"notify" to all observers with a particular event "e". 
\begin{caml_example}
class ['observer, 'event] subject =
  object (self)
    val mutable observers = ([]:'observer list)
    method add_observer obs = observers <- (obs :: observers)
    method notify_observers (e : 'event) = 
        List.iter (fun x -> x#notify self e) observers
  end;;
\end{caml_example}
The difficulty usually relies  in defining instances of the pattern above
by inheritance. This can be done in a natural and obvious manner in
Ocaml, as shown on the following example manipulating windows.
\begin{caml_example}
type event = Raise | Resize | Move;;
let string_of_event = function
    Raise -> "Raise" | Resize -> "Resize" | Move -> "Move";;
let count = ref 0;;
class ['observer] window_subject =
  let id = count := succ !count; !count in
  object (self)
    inherit ['observer, event] subject
    val mutable position = 0
    method identity = id
    method move x = position <- position + x; self#notify_observers Move
    method draw = Printf.printf "{Position = %d}\n"  position;
  end;;
class ['subject] window_observer =
  object
    inherit ['subject, event] observer
    method notify s e = s#draw
  end;;
\end{caml_example}
Unsurprisingly the type of "window" is recursive. 
\begin{caml_example}
let window = new window_subject;;
\end{caml_example}
However, the two classes of "window_subject" and "window_observer" are not
mutually recursive. 
\begin{caml_example}
let window_observer = new window_observer;;
window#add_observer window_observer;;
window#move 1;;
\end{caml_example}

Classes "window_observer" and "window_subject" can still be extended by
inheritance. For instance, one may enrich the "subject" with new
behaviors and refined the behavior of the observer. 
\begin{caml_example}
class ['observer] richer_window_subject =
  object (self)
    inherit ['observer] window_subject
    val mutable size = 1
    method resize x = size <- size + x; self#notify_observers Resize
    val mutable top = false
    method raise = top <- true; self#notify_observers Raise
    method draw = Printf.printf "{Position = %d; Size = %d}\n"  position size;
  end;;
class ['subject] richer_window_observer =
  object 
    inherit ['subject] window_observer as super
    method notify s e = if e <> Raise then s#raise; super#notify s e
  end;;
\end{caml_example}
We can also create a different kind of observer: 
\begin{caml_example}
class ['subject] trace_observer = 
  object 
    inherit ['subject, event] observer
    method notify s e =
      Printf.printf
        "<Window %d <== %s>\n" s#identity (string_of_event e)
  end;;
\end{caml_example}
and combine them as follows:
\begin{caml_example}
let window = new richer_window_subject;;
window#add_observer (new richer_window_observer);;
window#add_observer (new trace_observer);;
window#move 1; window#resize 2;;
\end{caml_example}

%\subsection{Classes used as modules with inheritance}
%
% to be filled for next release...
%
% an example of stateless objects used to provide inheritance in modules
%


% LocalWords:  Caml objectexamples bsection init caml val int Oo succ incr ref
% LocalWords:  typecheck leq bool cp eval sig struct ABSPOINT Abspoint iter
% LocalWords:  accu mem rec repr
